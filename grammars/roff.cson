name: "Roff"
scopeName: "text.roff"
fileTypes: [
	"1", "1b", "1c", "1has", "1in", "1m", "1s", "1x",
	"2",
	"3", "3avl", "3bsm", "3c", "3in", "3m", "3qt", "3x",
	"4",
	"5",
	"6",
	"7", "7d", "7fs", "7i", "7ipp", "7m", "7p",
	"8",
	"9", "9e", "9f", "9p", "9s",
	"groff",
	"man",
	"mandoc",
	"mdoc",
	"me",
	"mmn", "mmt",
	"ms",
	"mom",
	"n",
	"nroff",
	"roff",
	"t",
	"tmac", "tmac-u",
	"tr",
	"troff"
]
firstLineMatch: """(?x)

	# Manual page with .TH macro on first line
	^\\.TH[ \t]+(?:\\S+)
	|
	
	# Preprocessor line
	# See: https://www.gnu.org/software/groff/manual/html_node/Preprocessors-in-man-pages.html
	^'\\\\\"\\x20[tre]+(?=\\s|$)
	|
	
	# Modeline
	(?i:
		# Emacs
		-\\*-(?:\\s*(?=[^:;\\s]+\\s*-\\*-)|(?:.*?[;\\s]|(?<=-\\*-))mode\\s*:\\s*)
			[gnt]?roff
		(?=[\\s;]|(?<![-*])-\\*-).*?-\\*-
		
		|
		
		# Vim
		(?:(?:\\s|^)vi(?:m[<=>]?\\d+|m)?|\\sex)(?=:(?=\\s*set?\\s[^\\n:]+:)|:(?!\\s* set?\\s))(?:(?:\\s|\\s*:\\s*)\\w*(?:\\s*=(?:[^\\n\\\\\\s]|\\\\.)*)?)*[\\s:](?:filetype|ft|syntax)\\s*=
			[gnt]?roff
		(?=\\s|:|$)
	)
"""
patterns: [{ include: "#main" }]


repository:
	
	# Common patterns
	main:
		patterns: [
			{include: "#preprocessors"}
			{include: "#escapes"}
			{include: "#requests"}
			{include: "#macros"}
		]
	
	
	# Control line parameters
	params:
		patterns: [
			{include: "#escapes"}
			{include: "#string"}
			{include: "#number"}
			{include: "#generic-parameter"}
		]
	
	
	# Numeric literal
	number:
		name: "constant.numeric.roff"
		match: "(?!\\d+[cfimnPpsuvz]\\w)(\\|)?(?:(?<!\\w)[-+])?(?:\\d+(?:\\.\\d*)?|\\.\\d+|(?<=[-+])\\.)([cfimnPpsuvz])?"
		captures:
			1: name: "keyword.operator.absolute.roff"
			2: name: "keyword.other.unit.roff"
	
	
	# "Double-quoted string"
	string:
		patterns: [{
			name: "string.quoted.double.empty.roff",
			match: '(?<=(?<=[^\\\\]|^)\\s|^)(")(")(?=\\s|$)'
			captures:
				1: {name: "punctuation.definition.string.begin.roff"}
				2: {name: "punctuation.definition.string.end.roff"}
		},{
			name: "string.quoted.double.roff",
			begin: '(?<=(?<=[^\\\\]|^)\\s|^)"(?!")'
			end:   '(?<!")"(?!")|(?<!\\\\)$|(?=\\\\\")'
			beginCaptures: {0: {name: "punctuation.definition.string.begin.roff"}}
			endCaptures:   {0: {name: "punctuation.definition.string.end.roff"}}
			patterns: [include: "#string-escapes"]
		}]
	
	
	# Escape sequences to match inside double-quoted strings
	"string-escapes":
		patterns: [
			{match: '""', name: "constant.character.escape.quote.double.roff"}
			{include: "#escapes"}
		]
	
	
	# Highlighting for macro arguments that don't match anything else
	"generic-parameter":
		name: "variable.parameter.roff"
		match: "[^\\s\\\\]+"
	
	
	# List of arguments passed to a request or macro
	"param-group":
		name: "function-call.arguments.roff"
		begin: "\\G|^"
		end:   "\\Z|$"
		patterns: [include: "#params"]
	
	
	# Bracket-delimited long-name (GNU)
	"long-name":
		patterns: [{
			name: "variable.parameter.other.roff"
			begin: "\\G\\s*"
			end:   "(?=\\]|\\s)"
			patterns: [include: "#escapes"]
		}
		{include: "#escapes"}
		{include: "#string"}
		{include: "#number"}]
	
	
	# Group of strings delimited with an arbitrary character
	"3-part-title":
		name: "string.3-part.other.roff"
		match: '\\G[ \t]*(.)((?:(?!\\1).)*)(\\1)((?:(?!\\1).)*)(\\1)((?:(?!\\1).)*)(\\1)'
		captures:
			1: name: "punctuation.definition.string.begin.roff"
			2: name: "entity.string.left.roff", patterns: [include: "#escapes"]
			3: name: "punctuation.definition.string.begin.roff"
			4: name: "entity.string.centre.roff", patterns: [include: "#escapes"]
			5: name: "punctuation.definition.string.end.roff"
			2: name: "entity.string.right.roff", patterns: [include: "#escapes"]
			7: name: "punctuation.definition.string.end.roff"
	
	
	
	# Requests
	requests:
		patterns:[{
			
			# GNU extensions
			name: "meta.function.request.$2.gnu.roff"
			begin: "(?x) ^([.'])[ \t]*
				(aln|als|asciify|backtrace|blm|boxa|box|brp|cflags|chop|close|composite|color
				|cp|devicem|device|do|ecs|ecr|evc|fam|fchar|fcolor|fschar|fspecial|ftr|fzoom
				|gcolor|hcode|hla|hlm|hpfa|hpfcode|hpf|hym|hys|itc|kern|length|linetabs|lsm
				|mso|nop|nroff|opena|open|output|pev|pnr|psbb|pso|ptr|pvs|rchar|rfschar|rj
				|rnn|schar|shc|shift|sizes|special|spreadwarn|sty|substring|tkf|tm1|tmc|trf
				|trin|trnt|troff|unformat|vpt|warnscale|warn|writec|writem|write)
				(?=\\s|\\\\[\"#])"
			end: "(?<!\\\\)(?=\n)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.request.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [{include: "#param-group"}]
		},{
			
			# .class: Assign a name to a range of characters (GNU)
			name: "meta.function.request.assign-class.gnu.roff"
			begin: "^([.'])[ \t]*(class)[ \t]+(\\S+)"
			end:   "(?<!\\\\)(?=$)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.request.roff"}
				2: {name: "entity.function.name.roff"}
				3: {name: "variable.parameter.roff"}
			patterns: [{
				match: "[^\\s\\\\]+(-)[^\\s\\\\]+"
				captures:
					0: name: "string.unquoted.character-range.roff"
					1: name: "punctuation.separator.dash.roff"
			}, include: "#params"]
		},{
			
			# .char: Define character or glyph (GNU)
			name: "meta.function.request.$2.gnu.roff"
			begin: "^([.'])[ \t]*(char)[ \t]*(\\S+)?[ \t]*(.*)(?=$|\\\\[\"#])"
			end:   "(?<!\\\\)(?=$)|(?=\\\\[\"#])"
			patterns: [include: "$self"]
			beginCaptures:
				1: {name: "punctuation.definition.request.roff"}
				2: {name: "storage.type.var.roff"}
				3: {name: "variable.parameter.roff"}
				4: {patterns: [include: "#param-group"]}
		},{
			
			# .defcolor: Define colour (GNU)
			name: "meta.function.request.define-colour.gnu.roff"
			begin: "^([.'])[ \t]*(defcolor)(?=\\s)[ \t]*((?:[^\\s\\\\]|\\\\(?![\"#]).)*)[ \t]*(rgb|cmyk?|gr[ae]y)?"
			end:   "(?<!\\\\)(?=$)|(?=\\\\[\"#])"
			beginCaptures:
				1: {name: "punctuation.definition.request.roff"}
				2: {name: "storage.type.var.roff"}
				3: {name: "string.other.colour-name.roff", patterns: [include: "#escapes"]}
				4: {name: "constant.language.colour-scheme.roff"}
			patterns: [{
				
				# Hexadecimal colour
				name: "constant.other.colour.hex.roff"
				match: "(\#{1,2})[A-Fa-f0-9]+"
				captures: 1: name: "punctuation.definition.colour.roff"
				
			}, include: "#params"]
		},{
			
			# Requests for controlling program flow (GNU)
			begin: "^([.'])[ \t]*(break|continue|return|while)(?=\\s)"
			end:   "(?<!\\\\)(?=$)|(?=\\\\\")"
			patterns: [include: "#param-group"]
			beginCaptures:
				0: {name: "meta.function.request.control.gnu.roff"}
				1: {name: "punctuation.definition.request.roff"}
				2: {name: "keyword.control.roff"}
		},{
			
			# Generic requests without formatting
			name: "meta.function.request.$2.roff"
			begin: "(?x) ^([.'])[ \t]*
				(ab|ad|af|bd|bp|br|c2|cc|ce|cf|ch|cs|cu|da|di|dt|ec|em|eo
				|ev|ex|fc|fi|fl|fp|ft|hc|hw|hy|in|it|lc|lg|lf|ll|ls|lt|mc
				|mk|na|ne|nf|nh|nm|nn|ns|nx|os|pc|pi|pl|pm|pn|po|ps|rd|rm
				|rn|rr|rs|rt|so|sp|ss|sv|sy|ta|tc|ti|tm|tr|uf|vs|wh)
				(?=\\s|\\d+\\s*$|\\\\[\"#])"
			end: "(?<!\\\\)(?=\n)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.request.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [{include: "#param-group"}]
			
		}
		{ include: "#conditionals" }
		{ include: "#definition"   }
		{ include: "#ignore"       }
		{ include: "#underlines"   }
		{
			# Register assignment
			name: "meta.function.request.$2.roff"
			begin: "^([.'])[ \t]*(nr)[ \t]*(?:(%|ct|dl|dn|dw|dy|ln|mo|nl|sb|st|yr)|(c\\.)|(\\${2}|\\.[$aAbcdfFhHijklLnopRTstuvVwxyz])|(\\.[CgmMOPUxyY])|(\\S+))?[ \t]*(.*)$"
			end: "(?<!\\\\)$"
			beginCaptures:
				1: {name: "punctuation.definition.request.roff"}
				2: {name: "storage.type.var.roff"}
				3: {name: "constant.language.predefined.register.roff"}
				4: {name: "constant.language.predefined.register.gnu.roff"}
				5: {name: "invalid.illegal.readonly.register.roff"}
				6: {name: "invalid.illegal.readonly.register.gnu.roff"}
				7: {name: "variable.parameter.roff"}
				8: {patterns: [include: "#param-group"]}
		},{
			
			# String definition
			name: "meta.function.request.$2.roff"
			begin: "^([.'])[ \t]*([ad]s1?)[ \t]+(((?:[^\\s\\\\]|\\\\(?!\").)+))?"
			end:   "(?<!\\\\)$"
			beginCaptures:
				1: name: "punctuation.definition.request.roff"
				2: name: "storage.type.var.roff"
				3: name: "variable.parameter.roff"
				4: name: "entity.name.roff", patterns: [include: "#escapes"]
			contentName: "string.unquoted.roff"
			patterns: [include: "#escapes"]
		},{
			
			# Three-part title
			name: "meta.function.request.$2.roff"
			begin: "^([.'])[ \t]*(tl)(?=\\s)"
			end:   "(?<!\\\\)$|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.request.roff"}
				2: {name: "entity.function.name.roff"}
			contentName: "function-call.arguments.roff"
			patterns: [
				{include: "#3-part-title"}
				{include: "#params"}
			]
		}]
	
	
	
	# Conditional input
	conditionals:
		patterns: [{
			
			# Conditional: If
			begin: """(?x)^
				([.'])   [ \t]*      # 1: punctuation.definition.request.roff
				(ie|if)  [ \t]*      # 2: keyword.control.roff
				(!)?                 # 3: keyword.operator.logical
				
				(?:
					# One-character built-in comparison name
					([notev])        # 4: constant.language.builtin-comparison.$4.roff
					
					|
					
					# GNU extensions
					([cdfmrs])       # 5: constant.language.builtin-comparison.$5.gnu.roff
					
					# Name being validated
					[ \t]*
					((?:[^ \\t\\\\]|\\\\(?!["#]).)+) # 6: Include “#escapes”
					
					|
					
					# Arithmetic
					(                # 7: meta.equation.roff
						
						# Starts with a bracket
						(\\()        # 8:  punctuation.definition.begin.roff
						(.*?)        # 9:  Include “#arithmetic”
						(\\))        # 10: punctuation.definition.end.roff
						
						# Anything else affixed to it
						(            # 11: Include “#arithmetic”
							(?:
								[^\\s\\(] | # Operators/numbers
								\\(.*?\\)   # More brackets
							)*
						)
						
						|
						
						# Doesn’t start with a bracket
						(?:
							# Starts with a long-form string/register
							(\\|?\\\\+[n*]\\(\\S{2}) # 12: Include “#escapes”
							|
							# Starts with a digit or backslash
							(?=\\d|\\\\)
						)
						([^\\s\\(]*) # 13: Sandwiched mathematical junk
						
						(?: # Possible embedded brackets
							(\\()    # 14: punctuation.definition.begin.roff
							(.*?)    # 15: Include “#arithmetic”
							(\\))    # 16: punctuation.definition.end.roff
						)?
						(?: # Possible trailing digits/operators
							[^\\s\\(]*?
							\\d+
						)?
						
						# Ends with a...
						(?<=
							# Digit
							\\d |
							
							# Unit suffix
							(?<=[\\d.])
							[A-Za-z] |
							
							# Closing bracket
							[\\)\\]] |
							
							# String/register: Long-form
							\\\\[n*]
							\\(
							\\S{2} |
							
							# String/register: Short-form
							\\\\[n*]\\S
						)
					)
					
					|
					
					# String/variable comparison
					([^\\d\\s\\\\])  # 17: punctuation.definition.string.begin.roff
					(                # 18: variable.parameter.operand.left.roff
						(.*?)        # 19: Include “#escapes”
					)
					(\\17)           # 20: punctuation.definition.string.roff
					(                # 21: variable.parameter.operand.right.roff
						(.*?)        # 22: Include “#escapes”
					)
					(\\17)           # 23: punctuation.definition.string.end.roff
					
					|
					
					# Anything not recognised
					(\\S)            # 24: meta.operand.single.roff
				)?
				
				(.*)                 # 25: Include “#conditional-innards”
			"""
			end: "$"
			beginCaptures:
				0:  {name: "meta.function.request.$2.roff"}
				1:  {name: "punctuation.definition.request.roff"}
				2:  {name: "keyword.control.roff"}
				3:  {name: "keyword.operator.logical"}
				4:  {name: "constant.language.builtin-comparison.$4.roff"}
				5:  {name: "constant.language.builtin-comparison.$5.gnu.roff"}
				6:  {patterns: [include: "#escapes"]}
				7:  {name: "meta.equation.roff"}
				8:  {name: "punctuation.definition.begin.roff"}
				9:  {patterns: [{include: "#arithmetic"}]}
				10: {name: "punctuation.definition.end.roff"}
				11: {patterns: [{include: "#arithmetic"}]}
				12: {patterns: [{include: "#escapes"}]}
				13: {patterns: [{include: "#arithmetic"}]}
				14: {name: "punctuation.definition.begin.roff"}
				15: {patterns: [{include: "#arithmetic"}]}
				16: {name: "punctuation.definition.end.roff"}
				17: {name: "punctuation.definition.string.begin.roff"}
				18: {name: "variable.parameter.operand.left.roff"}
				19: {patterns: [{include: "#escapes"}]}
				20: {name: "punctuation.definition.string.roff"}
				21: {name: "variable.parameter.operand.right.roff"}
				22: {patterns: [{include: "#escapes"}]}
				23: {name: "punctuation.definition.string.end.roff"}
				24: {name: "meta.operand.single.roff"}
				25: {patterns: [{include: "#conditional-innards"}]}
		},{
			
			# Conditional: Else
			begin: "^([.'])[ \t]*(el)\\s*(.*)"
			end:   "$"
			beginCaptures:
				0: {name: "meta.function.request.$2.roff"}
				1: {name: "punctuation.definition.request.roff"}
				2: {name: "keyword.control.roff"}
				3: {patterns: [{include: "#conditional-innards"}]}
		}]
	
	"conditional-innards":
		patterns: [{
			begin: "^\\s*(\\\\\\{(?:\\\\(?=\\n))?)?\\s*(.*)"
			end:   "$"
			beginCaptures:
				1: {name: "punctuation.section.conditional.begin.roff"}
				2: {patterns: [{include: "$self"}]}
		}]
	
	
	
	# Basic arithmetic sequences
	arithmetic:
		patterns: [
			{include: "#escapes"},
			{
				name: "meta.brackets.roff"
				match: "(\\()(.*?)(\\))"
				captures:
					1: {name: "punctuation.arithmetic.begin.roff"}
					2: {patterns: [{include: "#arithmetic"}]}
					3: {name: "punctuation.arithmetic.end.roff"}
			}
			{include: "#number"}
			{match: "[-/+*%]",     name: "keyword.operator.arithmetic.roff"}
			{match: ":|&|[<=>]=?", name: "keyword.operator.logical.roff"}
			{match: "\\|",         name: "keyword.operator.absolute.roff"}
		]
	
	

	# Macro definitions
	definition:
		patterns: [{
			
			# No terminator specified
			name: "meta.function.definition.request.$2.roff"
			begin: "^([.'])[ \t]*((dei?1?)|(ami?1?))\\s+(\\S+?)?\\s*(\\\\[\"#].*)?$"
			end:   "^(?:[ \t]*\\x5C{2})?\\.[ \t]*\\."
			beginCaptures:
				1: {name: "punctuation.definition.request.roff"}
				3: {name: "storage.type.function.roff"}
				4: {name: "entity.name.function.roff"}
				5: {name: "variable.parameter.roff"}
				6: {patterns: [include: "#escapes"]}
				7: {patterns: [include: "#param-group"]}
			endCaptures:
				0: {name: "punctuation.definition.request.roff"}
			patterns: [include: "$self"]
		},{
			
			# Terminator included
			name: "meta.function.definition.request.with-terminator.$2.roff"
			begin: "^([.'])[ \t]*((dei?1?)|(ami?1?))\\s+(\\S+)\\s*(\"[^\"]+\"?|\\S+?(?=\\s|\\\\[\"#]))?(.*)$"
			end:   "^(\\.)[ \t]*((\\6)(?=$|\\s|\\\\(?:$|\")))"
			beginCaptures:
				1: {name: "punctuation.definition.request.roff"}
				3: {name: "storage.type.function.roff"}
				4: {name: "entity.name.function.roff"}
				5: {name: "variable.parameter.roff"}
				6: {name: "keyword.control.terminator.roff", patterns: [include: "#string"]}
				7: {patterns: [include: "#param-group"]}
			endCaptures:
				1: {name: "punctuation.definition.request.roff"}
				2: {name: "keyword.control.terminator.roff"}
				3: {patterns: [{include: "#string"}]}
			patterns: [{include: "$self"}]
		}]
	
	
	# Ignored content
	ignore:
		patterns: [{
			
			# Terminator specified
			contentName: "comment.block.ignored-input.with-terminator.roff"
			begin: "^([.'])[ \t]*(ig)[ \t]+(?!\\\\[\"#])((\"[^\"]+\")|\\S+?(?=\\s|\\\\[\"#]))(.*)$"
			end:   "^([.'])[ \t]*(\\3)(?=\\s|$|\\\\)"
			patterns: [include: "#register-expansion"]
			beginCaptures:
				1: name: "punctuation.definition.request.roff"
				2: name: "entity.function.name.roff"
				3: name: "keyword.control.terminator.roff"
				4: patterns: [include: "#string"]
				5: patterns: [include: "#params"]
			endCaptures:
				1: name: "punctuation.definition.request.roff"
				2: name: "keyword.control.terminator.roff", patterns: [include: "#string"]
		},{
			
			# No terminator given
			contentName: "comment.block.ignored-input.roff"
			begin: "^([.'])[ \t]*(ig)(?=\\s|\\\\[\"#])(.*)$"
			end:   "^([.'])[ \t]*\\.(?=\\s|\\\\[\"#])"
			patterns: [include: "#register-expansion"]
			beginCaptures:
				1: name: "punctuation.definition.request.roff"
				2: name: "entity.function.name.roff"
				3: patterns: [include: "#params"]
			endCaptures:
				0: name: "punctuation.definition.request.roff"
		}]
	

	# Underlined passages
	underlines:
		patterns: [{
			
			# .ul 0: Empty request/noop
			name: "meta.request.ul.roff"
			match: "^([.'])[ \t]*(ul)\\s*(0+)(?:(?!\\\\\")[\\D])*(?=\\s|$)(.*)$"
			captures:
				1: {name: "punctuation.definition.function.request.roff"}
				2: {name: "entity.function.name.roff"}
				3: {name: "constant.numeric.roff"}
				4: {patterns: [{include: "#params"}]}
			
		}, {
			
			# Underline following line
			name: "meta.request.ul.roff"
			begin: "^([.'])[ \t]*(ul)(.*?)$\\n"
			end:   "(?<!\\\\)$"
			beginCaptures:
				1: {name: "punctuation.definition.function.request.roff"}
				2: {name: "entity.function.name.roff"}
				3: {patterns: [{include: "#params"}]}
			patterns: [{
				
				# Ignore control-lines
				begin: "^(?=[.']|\\\\!)(.*)$\\n"
				end:   "^"
				beginCaptures:
					1: {patterns: [{include: "$self"}]}
			}, {
				name: "markup.underline.roff"
				begin: "^(?![.'])"
				end:   "(?<!\\\\)$"
			}]
		}]
	
	
	
	
	
	# Escape sequences
	escapes:
		patterns: [
			{include: "#escapes-copymode"}
			{include: "#escapes-full"}
		]
	
	
	# Register interpolation
	"register-expansion":
		patterns: [{
			
			# \n[xx] - Contents of number register "XX" (GNU)
			name: "constant.character.escape.function.expand-register.gnu.roff"
			begin: "(\\|)?(((?:(?<=\\|)\\\\*?)?\\\\)n([-+])?(\\[))"
			end: "(\\])|(?<!\\\\)(?=$)"
			patterns: [include: "#long-name"]
			beginCaptures:
				1: {name: "keyword.operator.absolute.roff"}
				2: {name: "entity.name.roff"}
				3: {name: "punctuation.definition.escape.roff"}
				4: {name: "keyword.operator.arithmetic.roff"}
				5: {name: "punctuation.section.begin.bracket.square.roff"}
			endCaptures:
				1: {name: "punctuation.section.end.bracket.square.roff"}
		},{
			
			# \nX, \n(XX - Contents of number register "X" or "XX"
			name: "constant.character.escape.function.expand-register.roff"
			match: """(?x)
				
				# 1: keyword.operator.absolute.roff
				(\\|)?
				
				# 2: entity.name.roff
				(
					# 3: punctuation.definition.escape.roff
					(
						(?:(?<=\\|)\\\\*?)?
						\\\\
					)
					n
					([-+])?   # 4: keyword.operator.arithmetic.roff
					(\\()     # 5: punctuation.definition.brace.roff
				)
				
				# Name of register
				(?:
					# 6: constant.language.predefined.register.roff
					(ct|dl|dn|dw|dy|ln|mo|nl|sb|st|yr)
					|
					# 7: constant.language.predefined.register.gnu.roff
					(c\\.)
					|
					# 8: constant.language.predefined.register.readonly.roff
					(\\${2}  |  \\.[$aAbcdfFhHijklLnopRTstuvVwxyz])
					|
					# 9: constant.language.predefined.register.readonly.gnu.roff
					(\\.[CgmMOPUxyY])
					|
					# 10: variable.parameter.roff
					(\\S{2})
				)
				
				|
				
				# 11: keyword.operator.absolute.roff
				(\\|)?
				
				# 12: entity.name.roff
				(
					# 13: punctuation.definition.escape.roff
					(
						(?:(?<=\\|)\\\\*?)?
						\\\\
					)
					n
				)
				
				# 14: keyword.operator.arithmetic.roff
				([-+])?
				
				# Name of register
				(?:
					(%) |  # 15: constant.language.predefined.register.roff
					(\\S)  # 16: variable.parameter.roff
				)
			"""
			captures:
				1:  {name: "keyword.operator.absolute.roff"}
				2:  {name: "entity.name.roff"}
				3:  {name: "punctuation.definition.escape.roff"}
				4:  {name: "keyword.operator.arithmetic.roff"}
				5:  {name: "punctuation.definition.brace.roff"}
				6:  {name: "constant.language.predefined.register.roff"}
				7:  {name: "constant.language.predefined.register.gnu.roff"}
				8:  {name: "constant.language.predefined.register.readonly.roff"}
				9:  {name: "constant.language.predefined.register.readonly.gnu.roff"}
				10: {name: "variable.parameter.roff"}
				11: {name: "keyword.operator.absolute.roff"}
				12: {name: "entity.name.roff"}
				13: {name: "punctuation.definition.escape.roff"}
				14: {name: "keyword.operator.arithmetic.roff"}
				15: {name: "constant.language.predefined.register.roff"}
				16: {name: "variable.parameter.roff"}
		}]
	
	
	# Limited range of escape sequences permitted in copy-mode
	"escapes-copymode":
		patterns: [{
			
			# Backslashed escape sequences: \t -> \\t
			match: "(\\\\+?)(?=\\1\\S)"
			name: "punctuation.definition.concealed.escape.backslash.roff"
		},{
			
			# Comments
			name: "comment.line.roff"
			begin: "(?:^(\\.|'+)\\s*)?(\\\\\")"
			end: "$"
			beginCaptures:
				1: {name: "punctuation.definition.comment.roff"}
				2: {name: "punctuation.definition.comment.roff"}
		},{
			
			# Newline-devouring comment (GNU)
			name: "comment.line.number-sign.gnu.roff"
			begin: "(?:^(\\.|'+)\\s*)?(\\\\\#).*$\\n?"
			end: "^"
			beginCaptures:
				1: {name: "punctuation.definition.comment.roff"}
				2: {name: "punctuation.definition.comment.roff"}
		},{
			# Empty control lines
			name: "comment.empty.roff"
			match: "^(\\.|'+)[ \t]*$"
			captures:
				1: {name: "punctuation.definition.comment.roff"}
		},{
			
			# Concealed newline
			name: "constant.character.escape.newline.roff"
			begin: "(\\\\)$\\n?"
			end:   "^(?:[.'])?"
			beginCaptures:
				1: name: "punctuation.definition.escape.roff"
		}
		
		# Basic sequences
		{include: "#register-expansion"}
		{match: "(\\\\)\\1", name: "constant.character.escape.backslash.roff",   captures: 1: name: "punctuation.definition.escape.roff"}
		{match: "(\\\\)t",   name: "constant.character.escape.tab.roff",         captures: 1: name: "punctuation.definition.escape.roff"}
		{match: "(\\\\)a",   name: "constant.character.escape.leader-char.roff", captures: 1: name: "punctuation.definition.escape.roff"}
		{match: "(\\\\)\\.", name: "constant.character.escape.dot.roff",         captures: 1: name: "punctuation.definition.escape.roff"}, {
			
			# \*[name].macro - Adhoc matching to improve tbl's "\*[3trans]" hack (GNU)
			begin: "^(\\\\\\*\\[[^\\]]+\\])\\s*(\\.\\w+.*)"
			end: "$"
			beginCaptures:
				1: patterns: [include: "#escapes"]
				2: patterns: [include: "#conditional-innards"]
		},{
			
			# \*[xx args…] - Interpolate string "xx" with optional arguments (GNU)
			name: "constant.character.escape.function.interpolate-string.gnu.roff"
			begin: "((\\\\)\\*(\\[))"
			end: "(\\])|(?<!\\\\)(?=$)"
			contentName: "function-call.arguments.roff"
			patterns: [include: "#long-name"]
			beginCaptures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "punctuation.section.begin.bracket.square.roff"}
			endCaptures:
				1: {name: "punctuation.section.end.bracket.square.roff"}
		},{
			
			# \*x, \*(xx - Interpolate string "x" or "xx"
			name: "constant.character.escape.function.interpolate-string.roff"
			match: "((\\\\)\\*(\\())(\\S{2})|((\\\\)\\*)(\\S)"
			captures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "punctuation.definition.brace.roff"}
				4: {name: "variable.parameter.roff"}
				5: {name: "entity.name.roff"}
				6: {name: "punctuation.definition.escape.roff"}
				7: {name: "variable.parameter.roff"}
		},{
			
			# \$N - Interpolate argument number N (valid range: 1-9)
			name: "constant.character.escape.function.interpolate-argument.roff"
			match: "((\\\\)\\$\\d)"
			captures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
		},{

			# \m[X] - Alternate syntax for setting drawing/background colour (GNU)
			name: "constant.character.escape.function.set-colour.gnu.roff"
			begin: "((\\\\)[Mm](\\[))"
			end: "(\\])|(?<!\\\\)(?=$)"
			contentName: "variable.parameter.roff"
			patterns: [include: "#params"]
			beginCaptures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "punctuation.section.begin.bracket.square.roff"}
			endCaptures:
				1: {name: "punctuation.section.end.bracket.square.roff"}
		},{
			
			# \mX, \m(XX - Set drawing or background colour to "X" (GNU)
			name: "constant.character.escape.function.set-colour.gnu.roff"
			match: "((\\\\)[Mm](\\())(\\S{2})|((\\\\)[Mm])(\\S)"
			captures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "punctuation.definition.brace.roff"}
				4: {name: "variable.parameter.roff"}
				5: {name: "entity.name.roff"}
				6: {name: "punctuation.definition.escape.roff"}
				7: {name: "variable.parameter.roff"}
		},{
			
			# \s[±n], \s±[n] - Set/adjust point-size (GNU)
			name: "constant.character.escape.function.point-size.gnu.roff"
			begin: "((\\\\)s([-+])?(\\[))"
			end: "(\\])|(?<!\\\\)(?=$)"
			contentName: "variable.parameter.roff"
			patterns: [include: "#params"]
			beginCaptures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "keyword.operator.arithmetic.roff"}
				4: {name: "punctuation.section.begin.bracket.square.roff"}
			endCaptures:
				1: {name: "punctuation.section.end.bracket.square.roff"}
		},{
			
			# "Parametric" escape sequences supported in Groff (GNU)
			name: "constant.character.escape.function.check-identifier.gnu.roff"
			begin: "((\\\\)(?!s[-+]?\\d)[ABRsZ])((.))"
			end:   "(\\4)|(?<!\\\\)(?=$)"
			contentName: "string.other.roff"
			patterns: [include: "#escapes"]
			beginCaptures:
				1: {name: "entity.name.function.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "string.other.roff"}
				4: {name: "punctuation.definition.begin.roff"}
			endCaptures:
				0: {name: "string.other.roff"}
				1: {name: "punctuation.definition.end.roff"}
		},{
			
			# \ON - Suppress troff output with signal "N" (GNU)
			name: "constant.character.escape.internal.gnu.roff"
			match: "((\\\\)O([0-4]))"
			captures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "constant.numeric.roff"}
		},{
			
			# \O5[xyz] - Write file "xyz" to STDERR; grohtml-specific (GNU)
			name: "constant.character.escape.internal.stderr-write-file.gnu.roff"
			begin: "((\\\\)O(5)(\\[))"
			end: "(\\])|(?<!\\\\)(?=$)"
			contentName: "string.unquoted.filename.roff"
			patterns: [include: "#escapes"]
			beginCaptures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "constant.numeric.roff"}
				4: {name: "punctuation.section.begin.bracket.square.roff"}
			endCaptures:
				1: {name: "punctuation.section.end.bracket.square.roff"}
		},{
			
			# \V[x] - Alternate syntax for interpolating environment variable (GNU)
			name: "constant.character.escape.function.interpolate-variable.gnu.roff"
			begin: "((\\\\)[VY](\\[))"
			end: "(\\])|(?<!\\\\)(?=$)"
			patterns: [include: "#long-name"]
			beginCaptures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "punctuation.section.begin.bracket.square.roff"}
			endCaptures:
				1: {name: "punctuation.section.end.bracket.square.roff"}
		},{
			
			# \Vx, \V(xx - Interpolate contents of environment variable (GNU)
			name: "constant.character.escape.function.interpolate-variable.gnu.roff"
			match: "((\\\\)[VY](\\())(\\S{2})|((\\\\)[VY])(\\S)"
			captures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "punctuation.definition.brace.roff"}
				4: {name: "variable.parameter.roff"}
				5: {name: "entity.name.roff"}
				6: {name: "punctuation.definition.escape.roff"}
				7: {name: "variable.parameter.roff"}
		},{
			
			# \?code\? - Embed a chunk of code in diversion (GNU)
			match: "((\\\\)(\\?))(.*)((\\\\)(\\?))"
			captures:
				1: {name: "constant.character.escape.embed-diversion.start.gnu.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "punctuation.definition.script.roff"}
				4: {name: "string.interpolated.roff", patterns: [include: "$self"]}
				5: {name: "constant.character.escape.embed-diversion.start.gnu.roff"}
				6: {name: "punctuation.definition.escape.roff"}
				7: {name: "punctuation.definition.script.roff"}
		},{
			
			# \$*, \$@, \$^ - Argument concatenation for macros/strings (GNU)
			name: "constant.character.escape.function.concatenated-arguments.gnu.roff"
			match: "((\\\\)\\$[*@^])"
			captures:
				1: {name: "variable.language.roff"}
				2: {name: "punctuation.definition.escape.roff"}
		},{
			
			# \$(nn - Expand n-th argument passed to macro or string (GNU)
			name: "constant.character.escape.function.interpolate-argument.gnu.roff"
			match: "((\\\\)\\$(\\())(\\S{2})"
			captures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "punctuation.definition.brace.roff"}
				4: {name: "variable.parameter.roff"}
		},{
			
			# \$[nnn] - Alternate syntax for expanding n-th macro/string argument (GNU)
			name: "constant.character.escape.function.interpolate-argument.gnu.roff"
			begin: "((\\\\)\\$(\\[))"
			end: "(\\])|(?<!\\\\)(?=$)"
			contentName: "variable.parameter.roff"
			patterns: [include: "#long-name"]
			beginCaptures:
				1: {name: "entity.name.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "punctuation.section.begin.bracket.square.roff"}
			endCaptures:
				1: {name: "punctuation.section.end.bracket.square.roff"}
		}]
	
	
	
	# Every other escape sequence
	"escapes-full":
		patterns: [
		
			# Basic sequences
			{match: "(\\\\)e",   name: "constant.character.escape.current-escape-char.roff",  captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)´",   name: "constant.character.escape.acute-accent.roff",         captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)`",   name: "constant.character.escape.grave-accent.roff",         captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)-",   name: "constant.character.escape.minus.roff",                captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\) ",   name: "constant.character.escape.space.roff",                captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)0",   name: "constant.character.escape.space.digit-width.roff",    captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)\\|", name: "constant.character.escape.space.one-sixth-em.roff",   captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)\\^", name: "constant.character.escape.space.one-twelfth-em.roff", captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)&",   name: "constant.character.escape.zero-width-marker.roff",    captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)%",   name: "constant.character.escape.hyphenation-char.roff",     captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)c",   name: "constant.character.escape.connect.roff",              captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)d",   name: "constant.character.escape.downwards.roff",            captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)p",   name: "constant.character.escape.spread-line.roff",          captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)r",   name: "constant.character.escape.reverse.roff",              captures: 1: name: "punctuation.definition.escape.roff"}
			{match: "(\\\\)u",   name: "constant.character.escape.upwards.roff",              captures: 1: name: "punctuation.definition.escape.roff"}, {
			
				# \(aa - Character named "aa"
				name: "constant.character.escape.function.named-char.roff"
				match: "(?x)
					((\\\\)(\\())
					(em|hy|bu|sq|ru|14|12|34|fi|fl|ff|Fi|Fl|de|dg|fm|ct|rg|co|pl|mi|eq|sc|aa|ga|ul|sl|ts|sr|rn|ap
					|ua|da|mu|di|cu|ca|sb|sp|ib|ip|if|pd|gr|no|is|pt|es|mo|br|dd|rh|lh|bs|or|ci|lt|lb|rt|rb|lk|rk
					|bv|lf|rf|lc|rc|[>=<|!]=|->|<-|[+]-|\\*[A-IK-UW-Z*a-ik-uw-z])"
				captures:
					1: {name: "entity.name.roff"}
					2: {name: "punctuation.definition.escape.roff"}
					3: {name: "punctuation.definition.brace.roff"}
					4: {name: "variable.parameter.roff"}
			},{
				
				# \[aa] - Character named "aa" (GNU)
				name: "constant.character.escape.function.named-char.gnu.roff"
				begin: "(\\\\)(\\[)"
				end: "(\\S*)(\\])|(?<!\\\\)(?=$)"
				patterns: [
					{include: "#params"}
					{match: '(?:[^\\s\\]\\\\]|\\\\(?!["#]).)+', name: "variable.parameter.roff"}
				]
				beginCaptures:
					1: {name: "punctuation.definition.escape.roff"}
					2: {name: "punctuation.section.begin.bracket.square.roff"}
				endCaptures:
					1: {patterns: [include: "#params"]}
					2: {name: "punctuation.section.end.bracket.square.roff"}
			},{
				
				# Conditional input: Begin
				name: "meta.function.begin.roff"
				match: "(?:^(\\.|'+)[ \t]*)?(\\\\\\{(?:\\\\(?=\\n))?)"
				captures:
					1: {name: "punctuation.definition.request.roff"}
					2: {name: "punctuation.section.conditional.begin.roff"}
			},{
				
				# Conditional input: End
				name: "meta.function.end.roff"
				match: "(?:^(\\.|'+)[ \t]*)?(\\\\\\}(?:\\\\(?=\\n))?)"
				captures:
					1: {name: "punctuation.definition.request.roff"}
					2: {name: "punctuation.section.conditional.end.roff"}
			},{
				
				# Parametric/function-like escape sequences
				name: "constant.character.escape.function.roff"
				begin: "((\\\\)[bCDhHSlLovwxXN])((.))"
				end:   "(\\4)|(?<!\\\\)(?=$)"
				contentName: "string.other.roff"
				patterns: [include: "#escapes"]
				beginCaptures:
					1: {name: "entity.name.function.roff"}
					2: {name: "punctuation.definition.escape.roff"}
					3: {name: "string.other.roff"}
					4: {name: "punctuation.definition.begin.roff"}
				endCaptures:
					0: {name: "string.other.roff"}
					1: {name: "punctuation.definition.end.roff"}
			},{
				
				# Transparent throughput
				name: "meta.throughput.roff"
				begin: "(\\\\)!"
				end: "(?<!\\\\)$"
				beginCaptures:
					0: {name: "constant.character.escape.transparent-line.roff"}
					1: {name: "punctuation.definition.escape.roff"}
				patterns: [{include: "#escapes-copymode"}]
			},{
				
				# Font: Roman/regular
				name: "constant.character.escape.font.roff"
				match: "(\\\\)f[RP1]"
				captures:
					0: {name: "entity.name.roff"}
					1: {name: "punctuation.definition.escape.roff"}
			}, {
				
				# Font: Italics (typically rendered by nroff as underlined text)
				begin: "((\\\\)f[I2])"
				end: "(?=\\\\f[A-Za-z0-9])|^(?=\\.(?:SH|SS|P|[HILPT]P)\\b)"
				beginCaptures:
					0: {name: "constant.character.escape.font.roff"}
					1: {name: "entity.name.roff"}
					2: {name: "punctuation.definition.escape.roff"}
				patterns: [
					{include: "$self"}
					{include: "#italic-word"}
				]
			},{
				
				# Font: Bold
				begin: "((\\\\)f[B3])"
				end: "(?=\\\\f[A-Za-z0-9])|^(?=\\.(?:SH|SS|P|[HILPT]P)\\b)"
				beginCaptures:
					0: {name: "constant.character.escape.font.roff"}
					1: {name: "entity.name.roff"}
					2: {name: "punctuation.definition.escape.roff"}
				patterns: [
					{include: "$self"}
					{include: "#bold-word"}
				]
			},{
				
				# Font: Bold and italic
				begin: "((\\\\)f4)"
				end: "(?=\\\\f[A-Za-z0-9])|^(?=\\.(?:SH|SS|P|[HILPT]P)\\b)"
				beginCaptures:
					0: {name: "constant.character.escape.font.roff"}
					1: {name: "entity.name.roff"}
					2: {name: "punctuation.definition.escape.roff"}
				patterns: [
					{include: "$self"}
					{include: "#bold-italic-word"}
				]
			},{
				
				# \f[XX] - Change to font named "XX" (GNU)
				name: "constant.character.escape.function.font.gnu.roff"
				begin: "((\\\\)[Ff](\\[))"
				end: "(\\])|(?<!\\\\)(?=$)"
				contentName: "variable.parameter.roff"
				patterns: [include: "#escapes"]
				beginCaptures:
					1: {name: "entity.name.roff"}
					2: {name: "punctuation.definition.escape.roff"}
					3: {name: "punctuation.section.begin.bracket.square.roff"}
				endCaptures:
					1: {name: "punctuation.section.end.bracket.square.roff"}
			},{
				
				# \fX, \f(XX, \fN - Change to font named "X" or "XX", or position N
				name: "constant.character.escape.function.font.roff"
				match: "((\\\\)[Ff](\\())(\\S{2})|((\\\\)[Ff])(\\S)"
				captures:
					1: {name: "entity.name.roff"}
					2: {name: "punctuation.definition.escape.roff"}
					3: {name: "punctuation.definition.brace.roff"}
					4: {name: "variable.parameter.roff"}
					5: {name: "entity.name.roff"}
					6: {name: "punctuation.definition.escape.roff"}
					7: {name: "variable.parameter.roff"}
			},{
				
				# \gx, \g(xx - Format of number register "x" or "xx"
				name: "constant.character.escape.function.format-register.roff"
				match: "((\\\\)g(\\())(\\S{2})|((\\\\)g)(\\S)"
				captures:
					1: {name: "entity.name.roff"}
					2: {name: "punctuation.definition.escape.roff"}
					3: {name: "punctuation.definition.brace.roff"}
					4: {name: "variable.parameter.roff"}
					5: {name: "entity.name.roff"}
					6: {name: "punctuation.definition.escape.roff"}
					7: {name: "variable.parameter.roff"}
			},{
				
				# \kX - Mark horizontal input place in register "X"
				name: "constant.character.escape.function.mark-input.roff"
				match: "((\\\\)k)(\\S)"
				captures:
					1: {name: "entity.name.roff"}
					2: {name: "punctuation.definition.escape.roff"}
					3: {name: "variable.parameter.roff"}
			},{
				
				# \sN, \s±N - Point-size change function; also \s(NN, \s±(NN
				name: "constant.character.escape.function.point-size.roff"
				match: "((\\\\)s[-+]?(\\()?)(\\d+)"
				captures:
					1: {name: "entity.name.roff"}
					2: {name: "punctuation.definition.escape.roff"}
					3: {name: "punctuation.definition.brace.roff"}
					4: {name: "variable.parameter.roff"}
			},{
				
				# \zC - Print "C" with zero width (without spacing)
				name: "constant.character.escape.function.zero-width-print.roff"
				match: "((\\\\)z)([^\\s\\\\])"
				captures:
					1: {name: "entity.name.roff"}
					2: {name: "punctuation.definition.escape.roff"}
					3: {name: "variable.parameter.roff"}
			},{
				
				# \Z - Any character not listed above
				name: "constant.character.escape.misc.roff"
				match: "(\\\\)\\S"
				captures:
					1: name: "punctuation.definition.escape.roff"
			}]
	
	
	
	
	# Macros
	macros:
		patterns: [
			{include: "#man"}
			{include: "#mdoc"}
			{include: "#ms"}
			{include: "#mm"}
			{include: "#me"}
			{include: "#www"}
			
			# Generic macro highlighting
			name: "meta.function.macro.roff"
			begin: "^([.'])[ \t]*((?:[^\\s\\\\]|\\\\(?![#\"]).)+)"
			end:   "(?<!\\\\)(?=$)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#param-group"]
		]
	
	
	# Document macros
	mdoc:
		patterns: [{
			
			# .Bf [ -emphasis | Em ]: Begin emphasised text
			name: "meta.function.begin-emphasis.unparsed.macro.mdoc.roff"
			begin: "^([.'])\\s*(Bf)[ \t]+(-emphasis|Em)(?=\\s)(.*)"
			end:   "^(?=[.']\\s*[BE]f\\s)"
			beginCaptures:
				1: name: "punctuation.definition.macro.roff"
				2: name: "entity.function.name.roff"
				3: name: "constant.language.option.mdoc.macro.roff"
				4: patterns: [include: "#escapes"]
			patterns: [
				{include: "$self"}
				{include: "#italic-word"}
			]
		},{

			# .Bf [ -literal | Li ]: Begin literal text
			name: "meta.function.begin-literal.unparsed.macro.mdoc.roff"
			begin: "^([.'])\\s*(Bf)[ \t]+(-literal|Li)(?=\\s)(.*)"
			end:   "^(?=[.']\\s*[BE]f\\s)"
			beginCaptures:
				1: name: "punctuation.definition.macro.roff"
				2: name: "entity.function.name.roff"
				3: name: "constant.language.option.mdoc.macro.roff"
				4: patterns: [include: "#escapes"]
			patterns: [
				{include: "$self"}
				{include: "#monospace-word"}
			]
		},{
			
			# .Bf [ -symbolic | Sy ]: Begin symbolic text
			name: "meta.function.begin-symbolic.unparsed.macro.mdoc.roff"
			begin: "^([.'])\\s*(Bf)[ \t]+(-symbolic|Sy)(?=\\s)(.*)"
			end:   "^(?=[.']\\s*[BE]f\\s)"
			beginCaptures:
				1: name: "punctuation.definition.macro.roff"
				2: name: "entity.function.name.roff"
				3: name: "constant.language.option.mdoc.macro.roff"
				4: patterns: [include: "#escapes"]
			patterns: [
				{include: "$self"}
				{include: "#bold-word"}
			]
		},{
			
			# .Rs/.Re: Bibliographic block
			begin: "^([.'])\\s*(Rs)(?=\\s)(.*)$"
			end:   "^([.'])\\s*(Re)(?=\\s)"
			patterns: [include: "#refer"]
			contentName: "meta.citation.mdoc.roff"
			beginCaptures:
				0: name: "meta.function.unparsed.macro.mdoc.roff"
				1: name: "punctuation.definition.macro.mdoc.roff"
				2: name: "entity.function.name.mdoc.roff"
				3: patterns: [include: "#escapes"]
			endCaptures:
				0: name: "meta.function.unparsed.macro.mdoc.roff"
				1: name: "punctuation.definition.mdoc.macro.roff"
				2: name: "entity.function.name.mdoc.roff"
		},{
			
			# Unparsed macros: passing callable macros as arguments won't invoke them
			name: "meta.function.$2.unparsed.macro.mdoc.roff"
			begin: "^([.'])\\s*(%[ABCDIJNOPQRTUV]|B[dfklt]|br|D[bdt]|E[dfklx]|F[do]|Hf|In|L[bp]|Nd|Os|Pp|R[esv]|Sm|sp|Ud)(?=\\s)"
			end:   "(?<!\\\\)$"
			beginCaptures:
				1: name: "punctuation.definition.macro.roff"
				2: name: "entity.function.name.roff"
			patterns: [
				{include: "#mdoc-delimiters"}
				{include: "#mdoc-args"}
				{include: "#generic-parameter"}
			]
		},{
			
			# Parsed macros: will execute callable mdoc macros
			name: "meta.function.$2.parsed.macro.mdoc.roff"
			begin: """(?x)^([.'])\\s*
				(Ac|Ad|An|Ao|Ap|Aq|Ar|At|Bc|Bo|Bq|Brc|Bro|Brq|Bsx|Bx|Cd|Cm|D1|Dc
				|Dl|Do|Dq|Dv|Dx|Ec|Em|En|Eo|Eq|Er|Es|Ev|Fa|Fc|Fl|Fn|Fr|Ft|Fx|Ic
				|It|Li|Lk|Me|Ms|Mt|Nm|No|Ns|Nx|Oc|Oo|Op|Ot|Ox|Pa|Pc|Pf|Po|Pq|Qc
				|Ql|Qo|Qq|Rd|Sc|Sh|So|Sq|Ss|St|Sx|Sy|Ta|Tn|Ux|Va|Vt|Xc|Xo|Xr)
				(?=\\s)"""
			end: "(?<!\\\\)$"
			beginCaptures:
				1: name: "punctuation.definition.macro.roff"
				2: name: "entity.function.name.roff"
			patterns: [
				{include: "#mdoc-callables"}
				{include: "#mdoc-args"}
				{include: "#generic-parameter"}
			]
		}]


	# Mdoc macros that're executed as arguments by "parsed" macros
	"mdoc-callables":
		patterns: [{
			
			# .Em: Emphasised text (Italic)
			name: "meta.function.$1.callable.macro.mdoc.roff"
			begin: "(?<=Em|Ar)\\G|(?<=\\s)(Em|Ar)(?=\\s)"
			end:   """(?x)
				(?<!\\\\)$ |
				(?=
					\\s+
					(?:Ac|Ad|An|Ao|Ap|Aq|Ar|At|Bc|Bo|Bq|Brc|Bro|Brq|Bsx|Bx|Cd|Cm|Dc|Do|Dq|Dv|Dx|Ec|Em
					|En|Eo|Er|Es|Ev|Fa|Fc|Fl|Fn|Fr|Ft|Fx|Ic|Li|Lk|Ms|Mt|Nm|No|Ns|Nx|Oc|Oo|Op|Ot|Ox|Pa
					|Pc|Pf|Po|Pq|Qc|Ql|Qo|Qq|Sc|So|Sq|Sx|Sy|Ta|Tn|Ux|Va|Vt|Xc|Xo|Xr)
					\\s   |
					\\\\" |
					\\\\f[A-Za-z0-9]
				)"""
			beginCaptures:
				1: name: "entity.function.name.roff"
			patterns: [
				{include: "#mdoc-args"}
				{include: "$self"}
				{include: "#italic-word"}
			]
		},{
			
			# .Sy: Symbolic text (Bold)
			name: "meta.function.$1.callable.macro.mdoc.roff"
			begin: "(?<=Sy|Fl|Cm)\\G|(?<=\\s)(Sy|Fl|Cm)(?=\\s)"
			end:   """(?x)
				(?<!\\\\)$ |
				(?=
					\\s+
					(?:Ac|Ad|An|Ao|Ap|Aq|Ar|At|Bc|Bo|Bq|Brc|Bro|Brq|Bsx|Bx|Cd|Cm|Dc|Do|Dq|Dv|Dx|Ec|Em
					|En|Eo|Er|Es|Ev|Fa|Fc|Fl|Fn|Fr|Ft|Fx|Ic|Li|Lk|Ms|Mt|Nm|No|Ns|Nx|Oc|Oo|Op|Ot|Ox|Pa
					|Pc|Pf|Po|Pq|Qc|Ql|Qo|Qq|Sc|So|Sq|Sx|Sy|Ta|Tn|Ux|Va|Vt|Xc|Xo|Xr)
					\\s   |
					\\\\" |
					\\\\f[A-Za-z0-9]
				)"""
			beginCaptures:
				1: name: "entity.function.name.roff"
			patterns: [
				{include: "#mdoc-args"}
				{include: "$self"}
				{include: "#bold-word"}
			]
		},{
			
			# .Li: Literal text (Monospaced)
			name: "meta.function.$1.callable.macro.mdoc.roff"
			begin: "(?<=Li)\\G|(?<=\\s)(Li)(?=\\s)"
			end:   """(?x)
				(?<!\\\\)$ |
				(?=
					\\s+
					(?:Ac|Ad|An|Ao|Ap|Aq|Ar|At|Bc|Bo|Bq|Brc|Bro|Brq|Bsx|Bx|Cd|Cm|Dc|Do|Dq|Dv|Dx|Ec|Em
					|En|Eo|Er|Es|Ev|Fa|Fc|Fl|Fn|Fr|Ft|Fx|Ic|Li|Lk|Ms|Mt|Nm|No|Ns|Nx|Oc|Oo|Op|Ot|Ox|Pa
					|Pc|Pf|Po|Pq|Qc|Ql|Qo|Qq|Sc|So|Sq|Sx|Sy|Ta|Tn|Ux|Va|Vt|Xc|Xo|Xr)
					\\s   |
					\\\\" |
					\\\\f[A-Za-z0-9]
				)"""
			beginCaptures:
				1: name: "entity.function.name.roff"
			patterns: [
				{include: "#mdoc-args"}
				{include: "$self"}
				{include: "#monospace-word"}
			]
		},{
			
			# .Lk/.Mt: Hyperlink or mailto
			name: "meta.function.$1.callable.macro.mdoc.roff"
			begin: "(?<=Lk|Mt)\\G|(?<=\\s)(Lk|Mt)(?=\\s)"
			end:   "$|(?=\\\\\")|(\\S+?)(?=$|\\s|\\\\\")"
			beginCaptures:
				1: name: "entity.function.name.roff"
			endCaptures:
				0: name: "markup.underline.link.hyperlink.mdoc.roff"
				1: patterns: [include: "#escapes"]
		},{
			# Embedded macro name inside argument list
			name: "meta.function.$1.callable.macro.mdoc.roff"
			match: """(?x) (?<=[ \t])
				(Ac|Ad|An|Ao|Ap|Aq|Ar|At|Bc|Bo|Bq|Brc|Bro|Brq|Bsx|Bx|Cd|Cm|Dc|Do|Dq|Dv|Dx|Ec|En
				|Eo|Er|Es|Ev|Fa|Fc|Fl|Fn|Fr|Ft|Fx|Ic|Li|Lk|Ms|Mt|Nm|No|Ns|Nx|Oc|Oo|Op|Ot|Ox|Pa|Pc
				|Pf|Po|Pq|Qc|Ql|Qo|Qq|Sc|So|Sq|Sx|Ta|Tn|Ux|Va|Vt|Xc|Xo|Xr)(?=\\s)"""
			captures:
				1: name: "entity.function.name.roff"
		}]


	# Arguments passed to mdoc macros
	"mdoc-args":
		patterns: [
			{include: "#escapes"}
			{include: "#string"}
			{
				# Document revision date
				name: "string.quoted.other.date.roff"
				begin: "\\$(?=Mdocdate)"
				end:   "\\$"
				beginCaptures: 0: name: "punctuation.section.begin.date.roff"
				endCaptures:   0: name: "punctuation.section.end.date.roff"
			},{
				# "Delimiters" (in mdoc's terms)
				name: "punctuation.delimiter.mdoc.macro.roff"
				match: "(?<=\\s)[(\\[.,:|;)\\]?!](?=\\s|$)"
			},{
				# Option flags used by some macros
				name: "constant.language.option.mdoc.macro.roff"
				match: """(?x)
					(?<=\\s) (-)
					(alpha|beta|bullet|centered|column|compact|dash|devel|diag|emphasis|enum|file|filled|hang
					|hyphen|inset|item|literal|nested|nosplit|ohang|ragged|split|std|symbolic|tag|type|unfilled
					|width|words|offset(?:\\s+(?:left|center|indent|indent-two|right))?)(?=\\s)"""
				captures: 1: name: "punctuation.definition.dash.roff"
			}]


	
	# Manuscript macros
	ms:
		patterns: [{
			name: "meta.function.${2:/downcase}.ms.macro.roff"
			begin: "(?x) ^([.'])[ \t]*
				(1C|2C|AB|AE|AI|AU|B1|B2|BT|BX|DA|DE|DS|EN|EQ|FE|FS|IP|KE|KF|KS|LG
				|LP|MC|ND|NH|NL|P1|PE|PP|PS|PT|PX|QP|RP|SH|SM|TA|TC|TE|TL|TS|XA|XE
				|XP|XS)(?=\\s)"
			end: "(?<!\\\\)(?=\n)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [{include: "#params"}]
		},{
			
			# Headers and footers
			name: "meta.function.${2:/downcase}.ms.macro.roff"
			contentName: "function-call.arguments.roff"
			begin: "^([.'])[ \t]*([EO][FH])(?=\\s)"
			end:   "(?<!\\\\)(?=\n)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [
				{include: "#3-part-title"}
				{include: "#escapes"}
				{include: "#string"}
			]
		},{
			
			# Deprecated macros
			name: "meta.deprecated.function.${2:/downcase}.ms.macro.roff"
			contentName: "function-call.arguments.roff"
			begin: "^([.'])[ \t]*((De|Ds))(?=\\s)"
			end: "(?<!\\\\)$|(?=\\s*\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {name: "invalid.deprecated.roff"}
			patterns: [
				{include: "#escapes"}
				{include: "#string"}
			]
		},{
		
			# Monospaced/constant-width text
			name: "meta.function.cw.ms.macro.roff"
			begin: "^([.'])[ \t]*(CW)(?=\\s)"
			end: "(?<!\\\\)$|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [{
				
				# Unquoted string
				name: "markup.raw.roff"
				begin: "\\G[ \t]*(?!\")(?=(?:[^\\s\\\\]|\\\\(?!\").)+)"
				end:   "(?<![^\\\\]\\\\|^\\\\)(?=\\s|$)|(?=\\\\\")"
				patterns: [include: "#escapes"]
			},{
			
				# Null argument
				name: "markup.raw.roff"
				match: '(")(")'
				captures:
					0: {name: "string.quoted.double.empty.roff"}
					1: {name: "punctuation.definition.string.begin.roff"}
					2: {name: "punctuation.definition.string.end.roff"}
			},{
				
				# Quoted string
				name: "string.quoted.double.roff"
				contentName: "markup.raw.roff"
				begin: '\\G[ \t]*(")'
				end:   '((?:"")*)"(?!")|(?<!\\\\)$|(?=\\\\\")'
				beginCaptures: 1: name: "punctuation.definition.string.begin.roff"
				endCaptures:
					0: name: "punctuation.definition.string.end.roff"
					1: name: "markup.raw.roff", patterns: [include: "#string-escapes"]
				patterns: [include: "#string-escapes"]
			}
			{include: "#escapes"}
			{include: "#string"}]
		},{
			
			# Underlined text
			name: "meta.function.ul.ms.macro.roff"
			begin: "^([.'])[ \t]*(UL)(?=\\s)"
			end: "(?<!\\\\)$|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#underline-first"]
		}]
	
	
	# Memorandum macros
	mm:
		patterns: [{
			name: "meta.function.${2:/downcase}.mm.macro.roff"
			begin: "(?x) ^([.'])[ \t]*
				(1C|2C|AE|AF|AL|APP|APPSK|AS|AST|AT|AU|AV|AVL|B1|B2|BE|BL|BS|BVL
				|COVER|COVEND|DE|DF|DL|DS|EC|EF|EH|EN|EOP|EPIC|EQ|EX|FC|FD|FE|FG
				|FS|GETHN|GETPN|GETR|GETST|H|HC|HM|HU|HX|HY|HZ|IA|IE|INITI|INITR
				|IND|INDP|ISODATE|LB|LC|LE|LI|LT|LO|MC|ML|MT|MOVE|MULB|MULN|MULE
				|nP|NCOL|NS|ND|OF|OH|OP|PGFORM|PGNH|PIC|PE|PF|PH|PS|PX?|RD|RF|RL
				|RP|RS|S|SA|SETR|SG|SK|SM|SP|TA?B|TC|TE|TL|TM|TP|TS|TX|TY|VERBON
				|VERBOFF|VL|VM|WA|WE|WC|\\)E)(?=\\s)"
			end: "(?<!\\\\)$|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [{include: "#params"}]
		}]
	
	
	# Paper-formatting macros
	me:
		patterns: [{
			
			# Assorted macros without special highlighting or pattern-matching
			name: "meta.function.${3:/downcase}.me.macro.roff"
			begin: "(?x) ^([.'])[ \t]*
				((?:[()][cdfqxz]|\\+\\+|\\+c)|
				(1c|2c|EN|EQ|GE|GS|PE|PS|TE|TH|TS|ba|bc|bu|bx|hx
				|hl|ip|lp|np|pd|pp|r|re|sk|sm|sz|tp|uh|xp)(?=\\s))"
			end: "(?<!\\\\)$|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				3: {name: "entity.function.name.roff"}
			patterns: [include: "#params"]
		},{
			
			# .(l: List
			begin: "^([.'])[ \t]*(\\(l)(?=\\s)"
			end:   "^([.'])[ \t]*(\\)l)(?=\\s)"
			contentName: "markup.list.unnumbered.roff"
			patterns: [include: "$self"]
			beginCaptures:
				0: {name: "meta.function.list.begin.me.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			endCaptures:
				0: {name: "meta.function.list.end.me.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
		},{
			
			# .b: Bold
			begin: "^([.'])[ \t]*(b)(?=\\s)"
			end: "(?<![^\\\\]\\\\|^\\\\)(?=$|\\n)|(?=\\\\\")"
			contentName: "function-call.arguments.roff"
			beginCaptures:
				0: {name: "meta.function.bold-text.me.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#bold-first"]
		},{
			
			# .i: Italic
			begin: "^([.'])[ \t]*(i)(?=\\s)"
			end: "(?<![^\\\\]\\\\|^\\\\)(?=$|\\n)|(?=\\\\\")"
			contentName: "function-call.arguments.roff"
			beginCaptures:
				0: {name: "meta.function.italic-text.me.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#italic-first"]
		},{
			
			# .bi: Bold/Italic
			begin: "^([.'])[ \t]*(bi)(?=\\s)"
			end: "(?<![^\\\\]\\\\|^\\\\)(?=$|\\n)|(?=\\\\\")"
			contentName: "function-call.arguments.roff"
			beginCaptures:
				0: {name: "meta.function.bold-italic-text.me.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#bold-italic-first"]
		},{
			
			# .u: Underline
			begin: "^([.'])[ \t]*(u)(?=\\s)"
			end: "(?<![^\\\\]\\\\|^\\\\)(?=$|\\n)|(?=\\\\\")"
			contentName: "function-call.arguments.roff"
			beginCaptures:
				0: {name: "meta.function.underline-text.me.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#underline-first"]
		},{
			
			# .sh: Section heading
			name: "markup.heading.section.function.me.macro.roff"
			begin: "^([.'])[ \t]*(sh)[ \t]+((?!\")\\S+)\\b[ \t]*(?!$|\\n|\\\\\")"
			end:   "(?<![^\\\\]\\\\|^\\\\)(?=$|\\n)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {name: "variable.parameter.roff", patterns: [include: "#params"]}
			patterns: [include: "#bold-first"]
		},{
			
			# Headers and footers
			name: "meta.function.${2:/downcase}.me.macro.roff"
			contentName: "function-call.arguments.roff"
			begin: "^([.'])[ \t]*(of|oh|he|eh|fo|ef)(?=\\s)"
			end:   "(?<!\\\\)(?=\n)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [
				{include: "#3-part-title"}
				{include: "#escapes"}
				{include: "#string"}
			]
		}]
	
	
	# Webpage macros
	www:
		patterns: [{
			
			name: "meta.function.${2:/downcase}.www.macro.roff"
			begin: "(?x) ^([.'])[ \t]*
				(ALN|BCL|BGIMG|DC|DLE|DLS|HEAD|HR|HTM?L|HX|JOBNAME
				|LI|LINKSTYLE|LK|LNE|LNS|MPIMG|NHR|P?IMG|TAG)(?=\\s)"
			end: "(?<!\\\\)$|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#params"]
		},{
			
			# Macros that take URIs as their first argument
			name: "meta.function.${2:/downcase}.www.macro.roff"
			begin: "^([.'])[ \t]*(URL|FTP|MTO)(?=\\s)"
			end:   "(?<!\\\\)(?=$)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#underline-first"]
		},{
			
			# Code blocks
			name: "meta.function.${2:/downcase}.www.macro.roff"
			contentName: "markup.raw.roff"
			begin: "^([.'])[ \t]*(CDS)(?=\\s|\\\\[\"#])\\s*(\\\\[#\"].*)?$"
			end:   "^([.'])[ \t]*(CDE)(?=\\s|\\\\[\"#])"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {patterns: [include: "#escapes"]}
			endCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "$self"]
		},{
			
			# Headings
			name: "markup.heading.$3.www.macro.roff"
			contentName: "string.unquoted.heading.roff"
			begin: "^([.'])[ \t]*(HnS)(?=\\s)(?:\\s*(\\d+))?(?:\\s*(\\\\[#\"].*)$)?"
			end:   "^([.'])[ \t]*(HnE)(?=\\s)(.*)$"
			beginCaptures:
				0: {name: "meta.function.${2:/downcase}.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {name: "constant.numeric.roff"}
				4: {patterns: [include: "#escapes"]}
			endCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {patterns: [include: "#escapes"]}
			patterns: [include: "$self"]
		},{
			
			# Ordered lists
			name: "meta.function.${2:/downcase}.www.macro.roff"
			contentName: "markup.list.ordered.roff"
			begin: "^([.'])[ \t]*(OLS)(?=\\s)\\s*(\\\\[#\"].*)?$"
			end:   "^([.'])[ \t]*(OLE)(?=\\s)"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {patterns: [include: "#escapes"]}
			endCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "$self"]
		},{
			
			# Unordered lists
			name: "meta.function.${2:/downcase}.www.macro.roff"
			contentName: "markup.list.ordered.roff"
			begin: "^([.'])[ \t]*(ULS)(?=\\s)\\s*(\\\\[#\"].*)?$"
			end:   "^([.'])[ \t]*(ULE)(?=\\s)"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {patterns: [include: "#escapes"]}
			endCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "$self"]
		}]
	
	
	
	# Manual-page macros
	man:
		patterns: [{
			
			# Various macros that don't need special highlighting
			name: "meta.function.${2:/downcase}.man.macro.roff"
			begin: "^([.'])[ \t]*(RE|RS|SM|BT|PT)(?=\\s)"
			end:   "(?<!\\\\)(?=$)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#param-group"]
		},{
		
			# Various deprecated macros
			name: "meta.deprecated.function.${2:/downcase}.man.macro.roff"
			begin: "^([.'])[ \t]*((AT|DT|PD|UC))(?=\\s)"
			end:   "(?<!\\\\)(?=$)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {name: "invalid.deprecated.roff"}
			patterns: [include: "#param-group"]
		},{
			# .TH: Title
			name: "markup.heading.title.function.man.macro.roff"
			patterns: [include: "#param-group"]
			begin: "^([.'])[ \t]*(TH)(?=\\s)"
			end: "(?<!\\\\)$|(?=\\\\\")"
			patterns: [include: "#escapes"]
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.name.function.roff"}
		},{
			
			# .SH: Section heading
			name: "markup.heading.section.function.man.macro.roff"
			patterns: [include: "#param-group"]
			begin: "^([.'])[ \t]*(SH)(?=\\s)"
			end: "(?<!\\\\)$|(?=\\\\\")"
			patterns: [include: "#escapes"]
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.name.function.roff"}
		},{
			
			# .SS: Subsection
			name: "markup.heading.subsection.function.man.macro.roff"
			patterns: [include: "#param-group"]
			begin: "^([.'])[ \t]*(SS)(?=\\s)"
			end: "(?<!\\\\)$|(?=\\\\\")"
			patterns: [include: "#escapes"]
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.name.function.roff"}
		},{
		
			# .EX: Example code
			contentName: "markup.raw.roff"
			begin: "^([.'])[ \t]*(EX)\\s*(\\\\[#\"].*)?$"
			end:   "^([.'])[ \t]*(EE)(?=\\s|\\\\[#\"])"
			patterns: [{ include: "$self" }]
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.function.macro.roff"}
				2: {name: "entity.name.function.roff"}
				3: {patterns: [{include: "#escapes-copymode"}]}
			endCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.function.macro.roff"}
				2: {name: "entity.name.function.roff"}
		},{
			
			# .LP/.PP/.P: Paragraph
			name: "meta.function.paragraph.man.macro.roff"
			begin: "^([.'])[ \t]*(LP|PP?)(?=\\s|\\\\[\"#])"
			end:   "(?<!\\\\)(?=$)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#params"]
		},{
			
			# .IP: Indented paragraph
			name: "meta.function.indented-paragraph.man.macro.roff"
			begin: "^([.'])[ \t]*(IP)(?=\\s|\\\\[\"#])"
			end:   "(?<!\\\\)(?=$)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
			patterns: [include: "#param-group"]
		},{
			
			# .TP: Titled paragraph
			begin: "^([.'])[ \t]*(TP)(?=\\s|\\\\[\"#])(.*)?$\\n?"
			end:   "^(.*)(?<!\\\\)$"
			patterns: [
				match: ".+"
				captures: 0: patterns: [include: "$self"]
			]
			beginCaptures:
				0: {name: "meta.function.titled-paragraph.man.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {patterns: [include: "#param-group"]}
			endCaptures:
				1: {patterns: [include: "$self"]}
		},{
			
			# .TQ: Header continuation for .TP (GNU extension)
			name: "markup.list.unnumbered.man.macro.gnu.roff"
			begin: "^([.'])[ \t]*(TQ)[ \t]*(\\\\[#\"].*)?$"
			end:   "^(?=[.'][ \t]*TP(?:\\s|\\\\[#\"]))"
			beginCaptures:
				0: {name: "meta.function.header-continuation.man.macro.gnu.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.gnu.roff"}
				3: {patterns: [include: "#escapes"]}
			patterns: [include: "$self"]
		},{
			# .HP: Hanging paragraph (deprecated)
			name: "meta.deprecated.function.hanging-paragraph.man.macro.roff"
			begin: "^([.'])[ \t]*((HP))(?=\\s|\\\\[\"#])"
			end:   "(?<!\\\\)(?=$)|(?=\\\\\")"
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {name: "invalid.deprecated.roff"}
			patterns: [include: "#param-group"]
		},{
			
			# .MT/.ME: Hyperlink (GNU extension)
			name: "meta.function.mailto.hyperlink.man.macro.gnu.roff"
			begin: "^([.'])[ \t]*(MT)(?=\\s|\\\\[\"#])"
			end:   "^([.'])[ \t]*(ME)(?=\\s|\\\\[\"#])(.*)\\s*(\\\\[\"#].*)?$"
			beginCaptures:
				1: {name: "punctuation.definition.macro.gnu.roff"}
				2: {name: "entity.function.name.gnu.roff"}
			endCaptures:
				1: {name: "punctuation.definition.macro.gnu.roff"}
				2: {name: "entity.function.name.gnu.roff"}
				3: {patterns: [include: "#param-group"]}
				4: {patterns: [include: "#escapes"]}
			patterns: [include: "#underline-first"]
		},{
			
			# .UR/.UE: URL (GNU extension)
			name: "meta.function.hyperlink.man.macro.gnu.roff"
			begin: "^([.'])[ \t]*(UR)(?=\\s|\\\\[\"#])"
			end:   "^([.'])[ \t]*(UE)(?=\\s|\\\\[\"#])(.*)\\s*(\\\\[\"#].*)?$"
			beginCaptures:
				1: {name: "punctuation.definition.macro.gnu.roff"}
				2: {name: "entity.function.name.gnu.roff"}
			endCaptures:
				1: {name: "punctuation.definition.macro.gnu.roff"}
				2: {name: "entity.function.name.gnu.roff"}
				3: {patterns: [include: "#param-group"]}
				4: {patterns: [include: "#escapes"]}
			patterns: [include: "#underline-first"]
		},{
			
			# .SY: Command synopsis (GNU extension)
			name: "meta.command-synopsis.roff"
			begin: "^([.'])[ \t]*(SY)(?=\\s|\\\\[\"#])"
			end:   "^([.'])[ \t]*(YS)(?=\\s|\\\\[\"#])"
			beginCaptures:
				0: {name: "meta.function.begin.synopsis.man.macro.gnu.roff"}
				1: {name: "punctuation.definition.macro.gnu.roff"}
				2: {name: "entity.function.name.gnu.roff"}
			endCaptures:
				0: {name: "meta.function.end.synopsis.man.macro.gnu.roff"}
				1: {name: "punctuation.definition.macro.gnu.roff"}
				2: {name: "entity.function.name.gnu.roff"}
			patterns: [include: "#bold-first", {
				
				# .OP: Option description (GNU extension)
				name: "meta.function.option-description.man.macro.gnu.roff"
				begin: "^([.'])[ \t]*(OP)(?=\\s)"
				end:   "(?<!\\\\)(?=\\n)|(?=\\\\\")"
				beginCaptures:
					1: {name: "punctuation.definition.macro.gnu.roff"}
					2: {name: "entity.function.name.gnu.roff"}
				patterns: [{
					name: "function-call.arguments.roff"
					begin: "\\G"
					end: '(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
					patterns: [
						{include: "#odd-bold"}
						{include: "#even-italic-after-bold"}
						{include: "#even-italic"}
						{include: "#bridge-escapes"}
					]
				}, include: "#escapes"]
			
			},{include: "$self"}]
		},{

			# .B/.SB: Bold
			begin: "^([.'])[ \t]*(S?B)(\\s*\\\\[#\"].*$)?(?=$|[ \t]+|\\\\)"
			end:   "^(?=[.'])|(?=\\\\\")|(?!\\\\#)((\\S+[ \t]*)(?<![^\\\\]\\\\)\n)"
			patterns: [include: "$self", {match: "\\S+", name: "markup.bold.roff"}]
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.function.macro.roff"}
				2: {name: "entity.name.function.roff"}
				3: {patterns: [{include: "#escapes-copymode"}]}
			endCaptures:
				1: {name: "markup.bold.roff"}
				2: {patterns: [{include: "#escapes"}]}
		},{
			
			# .I: Italic
			begin: "^([.'])[ \t]*(I)(\\s*\\\\[#\"].*$)?(?=$|[ \t]+|\\\\)"
			end:   "^(?=[.'])|(?=\\\\\")|(?!\\\\#)((\\S+[ \t]*)(?<![^\\\\]\\\\)\n)"
			patterns: [include: "$self", {match: "\\S+", name: "markup.italic.roff"}]
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.function.macro.roff"}
				2: {name: "entity.name.function.roff"}
				3: {patterns: [{include: "#escapes-copymode"}]}
			endCaptures:
				1: {name: "markup.italic.roff"}
				2: {patterns: [{include: "#escapes"}]}
		
		}, include: "#alternating-fonts"]


	# Repeating/combined-font macros
	"alternating-fonts":
		patterns: [{
			
			# .BI: Bold + Italic
			begin: "^([.'])[ \t]*(BI)(?=\\s)"
			end:   '(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.function.macro.roff"}
				2: {name: "entity.name.function.roff"}
			patterns: [
				{include: "#odd-bold"}
				{include: "#even-italic-after-bold"}
				{include: "#even-italic"}
				{include: "#bridge-escapes"}
			]
		},{
			
			# .BR: Bold + Roman
			begin: "^([.'])[ \t]*(BR)(?=\\s)"
			end:   '(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.function.macro.roff"}
				2: {name: "entity.name.function.roff"}
			patterns: [
				{include: "#odd-bold"}
				{include: "#even-roman-after-bold"}
				{include: "#even-roman"}
				{include: "#bridge-escapes"}
			]
		},{
			
			# .IB: Italic + Bold
			begin: "^([.'])[ \t]*(IB)(?=\\s)"
			end:   '(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.function.macro.roff"}
				2: {name: "entity.name.function.roff"}
			patterns: [
				{include: "#odd-italic"}
				{include: "#even-bold-after-italic"}
				{include: "#even-bold"}
				{include: "#bridge-escapes"}
			]
		},{
			
			# .IR: Italic + Roman
			begin: "^([.'])[ \t]*(IR)(?=\\s)"
			end:   '(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.function.macro.roff"}
				2: {name: "entity.name.function.roff"}
			patterns: [
				{include: "#odd-italic"}
				{include: "#even-roman-after-italic"}
				{include: "#even-roman"}
				{include: "#bridge-escapes"}
			]
		},{
			
			# .RB: Roman + Bold
			begin: "^([.'])[ \t]*(RB)(?=\\s)"
			end:   '(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.function.macro.roff"}
				2: {name: "entity.name.function.roff"}
			patterns: [
				{include: "#odd-roman"}
				{include: "#even-bold-after-roman"}
				{include: "#even-bold"}
				{include: "#bridge-escapes"}
			]
		},{
			
			# .RI: Roman + Italic
			begin: "^([.'])[ \t]*(RI)(?=\\s)"
			end:   '(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures:
				0: {name: "meta.function.man.macro.roff"}
				1: {name: "punctuation.definition.function.macro.roff"}
				2: {name: "entity.name.function.roff"}
			patterns: [
				{include: "#odd-roman"}
				{include: "#even-italic-after-roman"}
				{include: "#even-italic"}
				{include: "#bridge-escapes"}
			]
		}]
	

	"bridge-escapes":
		patterns: [{
			
			name: "constant.character.escape.newline.roff"
			begin: "[ \t]+(\\\\)$\\n?"
			end:   "^"
			beginCaptures:
				1: name: "punctuation.definition.escape.roff"
		},{
			
			name: "constant.character.escape.newline.roff"
			begin: "(\\\\)$\\n?"
			end:   "^[ \t]*"
			beginCaptures:
				1: name: "punctuation.definition.escape.roff"
		}]


	"odd-bold":
		patterns: [{
			name: "markup.bold.roff"
			begin: '[ \t]+(")'
			end:   '(")[ \t]*|(?=\\\\")|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)'
			beginCaptures: 1: name: "punctuation.definition.string.begin.roff"
			endCaptures:   1: name: "punctuation.definition.string.end.roff"
			patterns: [{
				match: '((?:[^"\\\\]|""|\\\\(?!").)+)(?!$)'
				captures: 1: patterns: [include: "#string-escapes"]
			}, include: "#string-escapes"]
		},{
			name: "markup.bold.roff"
			begin: '[ \t]+(\\\\$\\n?)'
			end:   '(?<!^)[ \t]+|(?=\\\\")|(?<!\\\\)(?=\\n|$)'
			beginCaptures: 1: patterns: [include: "#escapes"]
			patterns: [include: "#escapes", {
				begin: "^[ \t]+"
				end: "(?=\\S)|(?<!\\\\)(?:$|\\n)"
			}]
		},{
			name: "markup.bold.roff"
			begin: '[ \t]+(?!")((?:[^\\s"\\\\]|\\\\(?!").)+)'
			end:   '[ \t]+|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures: 1: patterns: [include: "#escapes"]
			patterns: [include: "#escapes"]
		}]


	"odd-italic":
		patterns: [{
			name: "markup.italic.roff"
			begin: '[ \t]+(")'
			end:   '(")[ \t]*|(?=\\\\")|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)'
			beginCaptures: 1: name: "punctuation.definition.string.begin.roff"
			endCaptures:   1: name: "punctuation.definition.string.end.roff"
			patterns: [{
				match: '((?:[^"\\\\]|""|\\\\(?!").)+)(?!$)'
				captures: 1: patterns: [include: "#string-escapes"]
			}, include: "#string-escapes"]
		},{
			name: "markup.italic.roff"
			begin: '[ \t]+(\\\\$\\n?)'
			end:   '(?<!^)[ \t]+|(?=\\\\")|(?<!\\\\)(?=\\n|$)'
			beginCaptures: 1: patterns: [include: "#escapes"]
			patterns: [include: "#escapes", {
				begin: "^[ \t]+"
				end: "(?=\\S)|(?<!\\\\)(?:$|\\n)"
			}]
		},{
			name: "markup.italic.roff"
			begin: '[ \t]+(?!")((?:[^\\s"\\\\]|\\\\(?!").)+)'
			end:   '[ \t]+|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures: 1: patterns: [include: "#escapes"]
			patterns: [include: "#escapes"]
		}]


	"odd-roman":
		patterns: [{
			name: "markup.plain.roff"
			begin: '[ \t]+(")'
			end:   '(")[ \t]*|(?=\\\\")|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)'
			beginCaptures: 1: name: "punctuation.definition.string.begin.roff"
			endCaptures:   1: name: "punctuation.definition.string.end.roff"
			patterns: [{
				match: '((?:[^"\\\\]|""|\\\\(?!").)+)(?!$)'
				captures: 1: patterns: [include: "#string-escapes"]
			}, include: "#string-escapes"]
		},{
			name: "markup.plain.roff"
			begin: '[ \t]+(\\\\$\\n?)'
			end:   '(?<!^)[ \t]+|(?=\\\\")|(?<!\\\\)(?=\\n|$)'
			beginCaptures: 1: patterns: [include: "#escapes"]
			patterns: [include: "#escapes", {
				begin: "^[ \t]+"
				end: "(?=\\S)|(?<!\\\\)(?:$|\\n)"
			}]
		},{
			name: "markup.plain.roff"
			begin: '[ \t]+(?!")((?:[^\\s"\\\\]|\\\\(?!").)+)'
			end:   '[ \t]+|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures: 1: patterns: [include: "#escapes"]
			patterns: [include: "#escapes"]
		}]



	"even-bold":
		patterns: [
			name: "markup.bold.roff"
			begin: '(?<=^|\\s|")(?!"|\\\\")((?:[^\\s"\\\\]|\\\\(?!").)+)'
			end:   '(?=[ \t])|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures: 1: patterns: [include: "#escapes"]
			patterns: [include: "#escapes"]
		]

	"even-italic":
		patterns: [
			name: "markup.italic.roff"
			begin: '(?<=^|\\s|")(?!"|\\\\")((?:[^\\s"\\\\]|\\\\(?!").)+)'
			end:   '(?=[ \t])|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures: 1: patterns: [include: "#escapes"]
			patterns: [include: "#escapes"]
		]
	
	"even-roman":
		patterns: [
			name: "markup.plain.roff"
			begin: '(?<=^|\\s|")(?!"|\\\\")((?:[^\\s"\\\\]|\\\\(?!").)+)'
			end:   '(?=[ \t])|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)|(?=\\\\")'
			beginCaptures: 1: patterns: [include: "#escapes"]
			patterns: [include: "#escapes"]
		]
	
	
	"even-bold-after-italic":
		patterns: [{
			contentName: "markup.bold.roff"
			begin: '(")'
			end:   '(("))([^"\\s]+[ \t]*)?|(?=\\\\")|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)'
			beginCaptures:
				0: name: "markup.bold.roff"
				1: name: "punctuation.definition.string.begin.roff"
			endCaptures:
				1: name: "markup.bold.roff"
				2: name: "punctuation.definition.string.end.roff"
				3: name: "markup.italic.roff"
			patterns: [{
				match: '((?:[^"\\\\]|""|\\\\(?!").)+)(?!$)'
				captures: 1: patterns: [include: "#string-escapes"]
			}, include: "#string-escapes"]
		}]
	
	"even-bold-after-roman":
		patterns: [{
			contentName: "markup.bold.roff"
			begin: '(")'
			end:   '(("))([^"\\s]+[ \t]*)?|(?=\\\\")|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)'
			beginCaptures:
				0: name: "markup.bold.roff"
				1: name: "punctuation.definition.string.begin.roff"
			endCaptures:
				1: name: "markup.bold.roff"
				2: name: "punctuation.definition.string.end.roff"
				3: name: "markup.plain.roff"
			patterns: [{
				match: '((?:[^"\\\\]|""|\\\\(?!").)+)(?!$)'
				captures: 1: patterns: [include: "#string-escapes"]
			}, include: "#string-escapes"]
		}]
	
	
	"even-italic-after-bold":
		patterns: [{
			contentName: "markup.italic.roff"
			begin: '(")'
			end:   '(("))([^"\\s]+[ \t]*)?|(?=\\\\")|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)'
			beginCaptures:
				0: name: "markup.italic.roff"
				1: name: "punctuation.definition.string.begin.roff"
			endCaptures:
				1: name: "markup.italic.roff"
				2: name: "punctuation.definition.string.end.roff"
				3: name: "markup.bold.roff"
			patterns: [{
				match: '((?:[^"\\\\]|""|\\\\(?!").)+)(?!$)'
				captures: 1: patterns: [include: "#string-escapes"]
			}, include: "#string-escapes"]
		}]
	
	"even-italic-after-roman":
		patterns: [{
			contentName: "markup.italic.roff"
			begin: '(")'
			end:   '(("))([^"\\s]+[ \t]*)?|(?=\\\\")|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)'
			beginCaptures:
				0: name: "markup.italic.roff"
				1: name: "punctuation.definition.string.begin.roff"
			endCaptures:
				1: name: "markup.italic.roff"
				2: name: "punctuation.definition.string.end.roff"
				3: name: "markup.plain.roff"
			patterns: [{
				match: '((?:[^"\\\\]|""|\\\\(?!").)+)(?!$)'
				captures: 1: patterns: [include: "#string-escapes"]
			}, include: "#string-escapes"]
		}]


	"even-roman-after-bold":
		patterns: [{
			contentName: "markup.plain.roff"
			begin: '(")'
			end:   '(("))([^"\\s]+[ \t]*)?|(?=\\\\")|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)'
			beginCaptures:
				0: name: "markup.plain.roff"
				1: name: "punctuation.definition.string.begin.roff"
			endCaptures:
				1: name: "markup.plain.roff"
				2: name: "punctuation.definition.string.end.roff"
				3: name: "markup.bold.roff"
			patterns: [{
				match: '((?:[^"\\\\]|""|\\\\(?!").)+)(?!$)'
				captures: 1: patterns: [include: "#string-escapes"]
			}, include: "#string-escapes"]
		}]

	"even-roman-after-italic":
		patterns: [{
			contentName: "markup.plain.roff"
			begin: '(")'
			end:   '(("))([^"\\s]+[ \t]*)?|(?=\\\\")|(?<![^\\\\]\\\\|^\\\\)(?=\\n|$)'
			beginCaptures:
				0: name: "markup.plain.roff"
				1: name: "punctuation.definition.string.begin.roff"
			endCaptures:
				1: name: "markup.plain.roff"
				2: name: "punctuation.definition.string.end.roff"
				3: name: "markup.italic.roff"
			patterns: [{
				match: '((?:[^"\\\\]|""|\\\\(?!").)+)(?!$)'
				captures: 1: patterns: [include: "#string-escapes"]
			}, include: "#string-escapes"]
		}]



	# Embolden first argument only
	"bold-first":
		patterns: [{
			
			# Unquoted string
			name: "markup.bold.roff"
			begin: "\\G[ \t]*(?!\")(?=(?:[^\\s\\\\]|\\\\(?!\").)+)"
			end:   "(?<![^\\\\]\\\\|^\\\\)(?=\\s|$)|(?=\\\\\")"
			patterns: [include: "#escapes"]
		},{
		
			# Null argument
			name: "markup.bold.roff"
			match: '(")(")'
			captures:
				0: {name: "string.quoted.double.empty.roff"}
				1: {name: "punctuation.definition.string.begin.roff"}
				2: {name: "punctuation.definition.string.end.roff"}
		},{
			# Quoted string
			name: "markup.bold.roff"
			contentName: "string.quoted.double.roff"
			begin: '\\G[ \t]*(")'
			end:   '((?:"")*)"(?!")|(?<!\\\\)(?:$|\\n)|(?=\\\\\")'
			beginCaptures:
				0: name: "string.quoted.double.roff"
				1: name: "punctuation.definition.string.begin.roff"
			endCaptures:
				0: name: "punctuation.definition.string.end.roff"
				1: name: "markup.bold.roff", patterns: [include: "#string-escapes"]
			patterns: [include: "#string-escapes"]
		}
		{include: "#escapes"}
		{include: "#string"}]
	
	
	# Italicise first argument only
	"italic-first":
		patterns: [{
			
			# Unquoted string
			name: "markup.italic.roff"
			begin: "\\G[ \t]*(?!\")(?=(?:[^\\s\\\\]|\\\\(?!\").)+)"
			end:   "(?<![^\\\\]\\\\|^\\\\)(?=\\s|$)|(?=\\\\\")"
			patterns: [include: "#escapes"]
		},{
		
			# Null argument
			name: "markup.italic.roff"
			match: '(")(")'
			captures:
				0: {name: "string.quoted.double.empty.roff"}
				1: {name: "punctuation.definition.string.begin.roff"}
				2: {name: "punctuation.definition.string.end.roff"}
		},{
			# Quoted string
			name: "markup.italic.roff"
			contentName: "string.quoted.double.roff"
			begin: '\\G[ \t]*(")'
			end:   '((?:"")*)"(?!")|(?<!\\\\)(?:$|\\n)|(?=\\\\\")'
			beginCaptures:
				0: name: "string.quoted.double.roff"
				1: name: "punctuation.definition.string.begin.roff"
			endCaptures:
				0: name: "punctuation.definition.string.end.roff"
				1: name: "markup.italic.roff", patterns: [include: "#string-escapes"]
			patterns: [include: "#string-escapes"]
		}
		{include: "#escapes"}
		{include: "#string"}]



	# Embolden and italicise first argument only
	"bold-italic-first":
		patterns: [{
			
			# Unquoted string
			name: "markup.bold.italic.roff"
			begin: "\\G[ \t]*(?!\")(?=(?:[^\\s\\\\]|\\\\(?!\").)+)"
			end:   "(?<![^\\\\]\\\\|^\\\\)(?=\\s|$)|(?=\\\\\")"
			patterns: [include: "#escapes"]
		},{
		
			# Null argument
			name: "markup.bold.italic.roff"
			match: '(")(")'
			captures:
				0: {name: "string.quoted.double.empty.roff"}
				1: {name: "punctuation.definition.string.begin.roff"}
				2: {name: "punctuation.definition.string.end.roff"}
		},{
			# Quoted string
			name: "markup.bold.italic.roff"
			contentName: "string.quoted.double.roff"
			begin: '\\G[ \t]*(")'
			end:   '((?:"")*)"(?!")|(?<!\\\\)(?:$|\\n)|(?=\\\\\")'
			beginCaptures:
				0: name: "string.quoted.double.roff"
				1: name: "punctuation.definition.string.begin.roff"
			endCaptures:
				0: name: "punctuation.definition.string.end.roff"
				1: name: "markup.bold.italic.roff", patterns: [include: "#string-escapes"]
			patterns: [include: "#string-escapes"]
		}
		{include: "#escapes"}
		{include: "#string"}]



	# Embolden a word
	"bold-word":
		name: "markup.bold.roff"
		match: "\\S+?(?=\\\\|$|\\s)"


	# Italicise a word
	"italic-word":
		match: "\\S+?(?=\\\\|$|\\s)"
		name: "markup.italic.roff"


	# Embolden and italicise a word
	"bold-italic-word":
		name: "markup.bold.italic.roff"
		match: "\\S+?(?=\\\\|$|\\s)"


	# Render a word as raw/verbatim text
	"monospace-word":
		name: "markup.raw.monospaced.roff"
		match: "\\S+?(?=\\\\|$|\\s)"



	# Underline first argument only
	"underline-first":
		patterns: [{
			
			# Unquoted string
			contentName: "markup.underline.roff"
			begin: "\\G[ \t]*(?!\")(?=(?:[^\\s\\\\]|\\\\(?!\").)+)"
			end:   "(?<![^\\\\]\\\\|^\\\\)(?=\\s|$)|(?=\\\\\")"
			patterns: [include: "#escapes"]
		},{
		
			# Null argument
			name: "string.quoted.double.empty.roff"
			match: '(")(")'
			beginCaptures: {0: {name: "punctuation.definition.string.begin.roff"}}
			endCaptures:   {0: {name: "punctuation.definition.string.end.roff"}}
		},{
			# Quoted string
			name: "string.quoted.double.roff"
			contentName: "markup.underline.roff"
			begin: '\\G[ \t]*(")'
			end:   '((?:"")*)"(?!")|(?<!\\\\)$|(?=\\\\\")'
			beginCaptures: 1: name: "punctuation.definition.string.begin.roff"
			endCaptures:
				0: name: "punctuation.definition.string.end.roff"
				1: name: "markup.underline.roff", patterns: [include: "#string-escapes"]
			patterns: [include: "#string-escapes"]
		}
		{include: "#escapes"}
		{include: "#string"}]



	# Preprocessors for preparing Troff documents
	preprocessors:
		patterns: [{
			
			# .TS/.TE: Tbl
			begin: "^([.'])[ \t]*(TS)(?=\\s|\\\\[\"#])(.*)"
			end:   "^([.'])[ \t]*(TE)(?=\\s|\\\\[\"#])"
			contentName: "markup.other.table.preprocessor.tbl.roff"
			patterns: [include: "#tbl"]
			beginCaptures:
				0: {name: "meta.function.begin.table.section.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {patterns: [include: "#escapes"]}
			endCaptures:
				0: {name: "meta.function.end.table.section.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.name.function.roff"}
		},{
			
			# .EQ/.EN: Eqn
			begin: "^([.'])[ \t]*(EQ)(?=\\s|\\\\[\"#])[ \t]*([LIC]\\b)?\\s*([^\\\\\"]+|\\\\[^\"])*(\\\\\".*)?$"
			end:   "^([.'])[ \t]*(EN)(?=\\s|\\\\[\"#])"
			contentName: "markup.other.math.preprocessor.eqn.roff"
			patterns: [include: "#eqn"]
			beginCaptures:
				0: {name: "meta.function.begin.math.section.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.function.name.roff"}
				3: {name: "constant.language.alignment-mode.eqn.roff"}
				4: {name: "string.unquoted.equation-label.eqn.roff"}
				5: {patterns: [include: "#escapes"]}
			endCaptures:
				0: {name: "meta.function.end.math.section.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.name.function.roff"}
		
		},{
			# .[/.]: Refer
			begin: "^([.'])[ \t]*(\\[)(.*?)\\s*(\\\\[\"#].*)?$"
			end:   "^([.'])[ \t]*(\\])(.*?)(?=\\s|$|\\\\\")"
			contentName: "meta.citation.roff"
			patterns: [{
				
				# First line: Flags + Keywords
				begin: "\\G"
				end: "$|(?=\\\\[#\"])"
				patterns: [{
					name: "constant.character.flags.refer.gnu.roff"
					match: "^[#\\[\\]]+"
				}, include: "#params"]
			
			}, include: "#refer"]
			beginCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "punctuation.section.function.begin.roff"}
				3: {name: "string.unquoted.opening-text.refer.roff", patterns: [include: "#escapes"]}
				4: {patterns: [include: "#escapes"]}
			endCaptures:
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "punctuation.section.function.end.roff"}
				3: {name: "string.unquoted.closing-text.refer.roff", patterns: [include: "#escapes"]}
		},{
			# .GS/.GE: Gremlin pictures
			begin: "^([.'])[ \t]*(GS)(?=\\s|\\\\[\"#])(.*)$"
			end:   "^([.'])[ \t]*(GE)(?=\\s|\\\\[\"#])"
			beginCaptures:
				0: name: "meta.function.begin.gremlin.macro.roff"
				1: name: "punctuation.definition.macro.roff"
				2: name: "entity.function.name.roff"
				3: patterns: [include: "#escapes"]
			endCaptures:
				0: {name: "meta.function.end.gremlin.macro.roff"}
				1: {name: "punctuation.definition.macro.roff"}
				2: {name: "entity.name.function.roff"}
			patterns: [
				
				# Gremlin keywords
				name: "keyword.operator.gremlin"
				match: """(?x)
					\\b((?:sun)?gremlinfile|ARC|BEZIER|BOTCENT|BOTLEFT|BOTRIGHT
					|BSPLINE|CENTCENT|CENTLEFT|CENTRIGHT|CURVE|POLYGON|TOPCENT
					|TOPLEFT|TOPRIGHT|VECTOR)\\b"""
				
				{include: "#params"}
			]
		}
		{include: "source.pic#tags"}
		{include: "source.ideal#tags"}]


	# Equation preprocessor
	eqn:
		patterns: [{
			
			# Greek letters
			name: "constant.language.greek-letter.eqn.roff"
			match: """(?x)\\b
				(DELTA|GAMMA|LAMBDA|OMEGA|PHI|PI|PSI|SIGMA|THETA|UPSILON|XI|alpha|beta|chi
				|delta|epsilon|eta|gamma|iota|kappa|lambda|mu|nu|omega|omicron|phi|pi|psi
				|rho|sigma|tau|theta|upsilon|xi|zeta)\\b"""
		},{
			# Math symbols
			name: "constant.character.math-symbol.eqn.roff"
			match: """(?x)\\b
				(sum|int|prod|union|inter|inf|partial|half|prime|approx|nothing|cdot
				|times|del|grad|[><=!]=|\\+-|->|<-|<<|>>|\\.{3}|,\\.,)\\b"""
		},{
			# Punctuation
			name: "punctuation.definition.eqn.roff"
			match: "[~,^{}]"
		},{
			# Eqn keywords
			name: "keyword.language.eqn.roff"
			match: """(?x)\\b
				(above|back|bar|bold|ccol|col|cpile|define|delim|dot|dotdot|down|dyad|fat|font|from
				|fwd|gfont|gsize|hat|italic|lcol|left|lineup|lpile|mark|matrix|ndefine|over|pile
				|rcol|right|roman|rpile|size|sqrt|sub|sup|tdefine|tilde|to|under|up|vec)\\b"""
		},{
			# GNU Eqn: Keywords
			name: "keyword.language.eqn.gnu.roff"
			match: """(?x)\\b
				(accent|big|chartype|smallover|type|vcenter|uaccent|split|nosplit
				|opprime|special|sdefine|include|ifdef|undef|g[rb]font|space)\\b"""
		},{
			
			# GNU Eqn: Character names
			name: "constant.language.eqn.gnu.roff"
			match: """(?x)\\b
				(Alpha|Beta|Chi|Delta|Epsilon|Eta|Gamma|Iota|Kappa|Lambda|Mu|Nu
				|Omega|Omicron|Phi|Pi|Psi|Rho|Sigma|Tau|Theta|Upsilon|Xi|Zeta
				|ldots|dollar)\\b"""
		},{
			
			# GNU Eqn: Set MathML variables
			name: "meta.set-variable.eqn.gnu.roff"
			match: """(?x)\\b(set)[ \t]+
				(accent_width|axis_height|baseline_sep|big_op_spacing[1-5]|body_depth|body_height|column_sep
				|default_rule_thickness|delimiter_factor|delimiter_shortfall|denom[12]|draw_lines|fat_offset
				|matrix_side_sep|medium_space|minimum_size|nroff|null_delimiter_space|num[12]|over_hang
				|script_space|shift_down|su[bp]_drop|sub[12]|sup[1-3]|thick_space|thin_space|x_height)\\b"""
			captures:
				1: name: "storage.type.var.eqn.roff"
				2: name: "variable.other.mathml.eqn.roff"
		
		}, include: "#string"]


	# Table preprocessor
	tbl:
		patterns: [{
			
			# Options/Formats
			name: "meta.function-call.arguments.tbl.roff"
			begin: "\\G|^((\\.)T&)[ \t]*$"
			end:   "(\\.)$\\n?|^(?=[.'][ \t]*TE(?=\\s))"
			beginCaptures:
				1: {name: "entity.function.name.roff"}
				2: {name: "punctuation.definition.macro.roff"}
			endCaptures:
				1: patterns: [include: "#params"]
				2: name: "punctuation.terminator.section.tbl.roff"
			patterns: [{
				
				# Not preprocessor source; abandon ship
				begin: "^(?=\\.)"
				end: "^(?=[.'][ \t]*TE(?=\\s|\\\\[\"#]))"
				patterns: [include: "$self"]},{
				
				
				# Global options
				match: "^(.+)(;)$"
				captures:
					1: patterns: [
						{match: ",", name: "punctuation.separator.comma.tbl.roff"}
						{match: "\\b(center|centre|expand|box|allbox|doublebox)\\b", name: "constant.language.$1.tbl.roff"}
						{match: "\\b((tab|linesize|delim)(\\()([^\\)\\s]*)(\\)))"
						captures:
							1: name: "constant.language.$2.tbl.roff"
							3: name: "punctuation.definition.arguments.begin.tbl.roff"
							4: patterns: [include: "#params"]
							5: name: "punctuation.definition.arguments.end.tbl.roff"}]
					2: name: "punctuation.terminator.line.tbl.roff"}
				
				# Field specifiers
				{match: "[ABCEFILNPRSTUVWZabcefilnprstuvwz^]", name: "constant.language.key-letter.tbl.roff"}
				{match: "[|_=]",     name: "punctuation.keyword.tbl.roff"}
				{match: "[-+]?\\d+", name: "constant.numeric.tbl.roff"}
				{match: "\\.",       name: "punctuation.delimiter.period.full-stop.tbl.roff"}
				{match: ",",         name: "punctuation.separator.comma.tbl.roff"}
				{include: "#params"}
			]
		},{
			
			# Horizontal line indicators
			name: "punctuation.keyword.tbl.roff"
			match: "^\\s*([=_]|\\\\_)\\s*$"
		},{
			
			# Column-filling repeated character sequence
			name: "constant.character.escape.repeat.tbl.roff"
			match: "(?<!\\\\)((\\\\)R)(.)"
			captures:
				1: {name: "keyword.operator.tbl.roff"}
				2: {name: "punctuation.definition.escape.roff"}
				3: {name: "string.unquoted.tbl.roff"}
		},{
			
			# Vertically-spanned item indicator
			name: "constant.character.escape.vertical-span.tbl.roff"
			match: "(\\\\)\\^"
			captures:
				0: {name: "keyword.operator.tbl.roff"}
				1: {name: "punctuation.definition.escape.roff"}
		},{
			
			# Multiline cell content
			name: "meta.multiline-cell.tbl.roff"
			contentName: "string.unquoted.tbl.roff"
			begin: "T(\\{)"
			end:  "^T(\\})|^(?=[.'][ \t]*TE\\b)"
			patterns: [include: "$self"]
			beginCaptures:
				0: name: "keyword.operator.section.begin.tbl.roff"
				1: name: "punctuation.embedded.tbl.roff"
			endCaptures:
				0: name: "keyword.operator.section.end.tbl.roff"
				1: name: "punctuation.embedded.tbl.roff"
			
		}, include: "$self"]


	# Bibliographic references
	refer:
		patterns: [{
			
			# Comment
			name: "comment.line.refer.roff"
			begin: "#"
			end:   "$"
			beginCaptures:
				0: name: "punctuation.definition.comment.refer.roff"
		},{
			
			# Names of each author, concatenated with the string specified by `join-authors`
			name: "variable.other.readonly.author-names.refer.roff"
			match: "@"
		},{
			
			# %KEY Value
			name: "meta.structure.dictionary.refer.roff"
			contentName: "meta.structure.dictionary.value.refer.rofff"
			begin: "^([.'])?\\s*(%)([A-Z])(?=\\s)"
			end:   "(?<!\\\\)$"
			patterns: [{
				name: "string.unquoted.refer.roff"
				begin: "\\G"
				end:   "(?<!\\\\)$"
				patterns: [{
					
					# Make sure "special" characters don't trigger refer patterns
					name: "meta.symbol.refer.roff"
					match: "[-+'\"<>\\].*\\[~!&?:]"
					
				}, include: "#refer"]
			}, include: "#escapes"]
			beginCaptures:
				1: name: "punctuation.definition.macro.mdoc.roff"
				2: name: "punctuation.definition.percentage-sign.refer.roff"
				3: name: "variable.other.readonly.key-letter.refer.roff"
		},{
			
			# Literal/single-quoted string
			name: "string.quoted.single.refer.roff"
			begin: "'"
			end:   "'"
			beginCaptures: 0: name: "punctuation.definition.string.begin.roff"
			endCaptures:   0: name: "punctuation.definition.string.end.roff"
		},{
			
			# Formatted/placeholder value
			name: "variable.other.readonly.formatted.refer.roff"
			match: "(%+)[\\daiA-Z]"
			captures:
				1: name: "punctuation.definition.percentage-sign.refer.roff"
		},{
			# Label expressions
			name: "keyword.operator.label-expression.refer.roff"
			match: """(?x)
				(?<=\\S)(?:\\*|[-+]\\d+|(\\.)(?:[-+]?y|[lucran]))(?=\\s|$) |
				(?<=\\S)[~!&?:](?=\\S)"""
			captures:
				1: name: "punctuation.separator.period.full-stop.refer.roff"
		},{
			
			# Angle brackets
			begin: "<"
			end:   ">|^(?=\\.\\])"
			beginCaptures: 0: name: "punctuation.bracket.angle.refer.roff"
			endCaptures:   0: name: "punctuation.bracket.angle.refer.roff"
			patterns: [include: "#refer"]
		},{
			
			# Round brackets
			begin: "\\("
			end:   "\\)|^(?=\\.\\])"
			beginCaptures: 0: name: "punctuation.bracket.round.refer.roff"
			endCaptures:   0: name: "punctuation.bracket.round.refer.roff"
			patterns: [include: "#refer"]
		},{
			
			# Negatable commands
			name: "keyword.operator.negatable.refer.roff"
			match: """(?x)\\b
				(?:no-)?
				(?:abbreviate|abbreviate-label-ranges|accumulate|annotate|compatible|date-as-label
				|default-database|discard|et-al|label-in-reference|label-in-text|move-punctuation
				|reverse|search-ignore|search-truncate|short-label|sort|sort-adjacent-labels)\\b"""
			captures:
				0: name: "entity.function.name.refer.roff"
		},{
			
			# Non-negatable commands
			name: "keyword.operator.refer.roff"
			match: "\\b(articles|bibliography|capitalize|join-authors|label|separate-label-second-parts)\\b"
			captures:
				0: name: "entity.function.name.refer.roff" 
		},{
			
			# Commands that take filenames as arguments
			begin: "^\\s*\\b(database|include)\\b"
			end: "(?<!\\\\)$"
			beginCaptures:
				0: name: "keyword.operator.refer.roff"
				1: name: "entity.function.name.refer.roff"
			patterns: [
				{include: "#escapes"}
				
				# Add underlines to filenames for themes supporting them
				name: "string.unquoted.filename.refer.roff"
				match: "((?:[^\\\\\\s]|\\\\(?!\").)+)"
				captures:
					0: name: "markup.link.underline.refer.roff"
					1: patterns: [include: "#escapes"]
			]
		}
		{include: "#string"}
		{include: "#escapes"}]
